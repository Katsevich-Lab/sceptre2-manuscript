library(lowmoi)
library(ondisc)
library(sceptre2)
result_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/extra_analyses/")
###########################
# STEP 1: SET UP SIMULATION
###########################
# 1. load Papalexi data
response_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/gene")
grna_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/grna_assignment")
grna_targets <- lowmoi::get_target_assignments_via_max_op(grna_odm)
# 2. get the gRNA group info
my_grna <- "CUL3"
grna_group_info <- lowmoi:::get_grna_group_info(grna_group_assignments = grna_targets,
input_grna_groups = my_grna)
idxs <- c(grna_group_info$grna_specific_idxs[[my_grna]],
grna_group_info$grna_specific_idxs[["non-targeting"]])
library(ondisc)
library(sceptre2)
result_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/extra_analyses/")
###########################
# STEP 1: SET UP SIMULATION
###########################
# 1. load Papalexi data
response_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/gene")
grna_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/grna_assignment")
grna_targets <- lowmoi::get_target_assignments_via_max_op(grna_odm)
# 2. get the gRNA group info
my_grna <- "CUL3"
grna_group_info <- sceptre2:::get_grna_group_info(grna_group_assignments = grna_targets,
input_grna_groups = my_grna)
idxs <- c(grna_group_info$grna_specific_idxs[[my_grna]],
grna_group_info$grna_specific_idxs[["non-targeting"]])
orig_x <- c(rep(1, grna_group_info$n_cells_per_grna[[my_grna]]),
rep(0, grna_group_info$n_cells_per_grna[["non-targeting"]]))
# 3. get covariate matrix
covariate_matrix_df <- response_odm |>
get_cell_covariates() |>
dplyr::slice(idxs) |>
dplyr::select(n_nonzero, n_umis, bio_rep, phase, p_mito)
row.names(covariate_matrix_df) <- NULL
Z <- model.matrix(object = formula(~ log(n_nonzero) + log(n_umis) + bio_rep + phase + p_mito),
data = covariate_matrix_df)
colnames(Z) <- c("intercept", "lg_n_nonzero", "lg_n_umis", "bio_rep_d1", "bio_rep_d2", "phase_d1", "phase_d2", "p_mito")
# 4. select gene
ex_gene <- "CXCL10"
orig_y <- as.numeric(response_odm[[ex_gene, idxs]])
# 5. get the model for y | Z
fit_y_orig <- MASS::glm.nb(formula = orig_y ~ . + 0, data = as.data.frame(Z))
y_coef <- coef(fit_y_orig)
theta <- fit_y_orig$theta
mus_y <- exp(as.numeric(Z %*% y_coef))
#################################
# STEP 2: RUN SIMULATION FUNCTION
#################################
run_simulation <- function(Y, idx_mat, Z, theta_hypothesized, n_sim = NULL, return_null_dist = FALSE, approx = TRUE) {
resamp_dist <- list()
if (is.null(n_sim)) n_sim <- ncol(Y)
out_m <- matrix(nrow = n_sim, ncol = 3)
for (i in seq(1, n_sim)) {
print(paste0("Running simulation ", i))
y <- Y[,i]
# regress the synthetic Y onto Z
fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta_hypothesized))
# extract z-scores
if (i == 1 || !approx) {
z_scores <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
# compute theoretical and empirical p-values
p_theory <- 2 * pnorm(q = -abs(z_star), lower.tail = TRUE)
p_camp <- lowmoi:::compute_empirical_p_value(z_star = z_star, z_null = z_null, "both")
# finally, compute permutation
ts <- lowmoi:::low_level_permutation_test(y = y, index_mat = idx_mat)
t_star <- ts[1]
t_null <- ts[-1]
p_perm <- lowmoi:::compute_empirical_p_value(t_star, t_null, "both")
out_m[i,] <- c(p_theory = p_theory, p_camp = p_camp, p_perm = p_perm)
if (i == 1) {
resamp_dist[["camp_null"]] <- z_null
resamp_dist[["camp_star"]] <- z_star
resamp_dist[["perm_null"]] <- ts
resamp_dist[["perm_star"]] <- t_star
}
}
colnames(out_m) <- c("p_theory", "p_camp", "p_perm")
return(list(out_m = out_m, resamp_dist = resamp_dist))
}
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
n_sim <- 2000
set.seed(3)
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# keep x fixed
x_idx <- which(orig_x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(orig_x), size = sum(orig_x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
# run sim
sim_res_correlated_corret_model <- run_simulation(Y = Y, idx_mat = idx_mat,
Z = Z, theta_hypothesized = theta,
return_null_dist = TRUE, approx = FALSE)
library(ondisc)
library(sceptre2)
result_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/extra_analyses/")
source("~/.Rprofile")
library(ondisc)
library(sceptre2)
result_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/extra_analyses/")
###########################
# STEP 1: SET UP SIMULATION
###########################
# 1. load Papalexi data
response_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/gene")
grna_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/grna_assignment")
grna_targets <- lowmoi::get_target_assignments_via_max_op(grna_odm)
# 2. get the gRNA group info
my_grna <- "CUL3"
grna_group_info <- sceptre2:::get_grna_group_info(grna_group_assignments = grna_targets,
input_grna_groups = my_grna)
idxs <- c(grna_group_info$grna_specific_idxs[[my_grna]],
grna_group_info$grna_specific_idxs[["non-targeting"]])
orig_x <- c(rep(1, grna_group_info$n_cells_per_grna[[my_grna]]),
rep(0, grna_group_info$n_cells_per_grna[["non-targeting"]]))
# 3. get covariate matrix
covariate_matrix_df <- response_odm |>
get_cell_covariates() |>
dplyr::slice(idxs) |>
dplyr::select(n_nonzero, n_umis, bio_rep, phase, p_mito)
row.names(covariate_matrix_df) <- NULL
Z <- model.matrix(object = formula(~ log(n_nonzero) + log(n_umis) + bio_rep + phase + p_mito),
data = covariate_matrix_df)
colnames(Z) <- c("intercept", "lg_n_nonzero", "lg_n_umis", "bio_rep_d1", "bio_rep_d2", "phase_d1", "phase_d2", "p_mito")
# 4. select gene
ex_gene <- "CXCL10"
orig_y <- as.numeric(response_odm[[ex_gene, idxs]])
# 5. get the model for y | Z
fit_y_orig <- MASS::glm.nb(formula = orig_y ~ . + 0, data = as.data.frame(Z))
y_coef <- coef(fit_y_orig)
theta <- fit_y_orig$theta
mus_y <- exp(as.numeric(Z %*% y_coef))
#################################
# STEP 2: RUN SIMULATION FUNCTION
#################################
run_simulation <- function(Y, idx_mat, Z, theta_hypothesized, n_sim = NULL, return_null_dist = FALSE, approx = TRUE) {
resamp_dist <- list()
if (is.null(n_sim)) n_sim <- ncol(Y)
out_m <- matrix(nrow = n_sim, ncol = 3)
for (i in seq(1, n_sim)) {
print(paste0("Running simulation ", i))
y <- Y[,i]
# regress the synthetic Y onto Z
fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta_hypothesized))
# extract z-scores
if (i == 1 || !approx) {
z_scores <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
# compute theoretical and empirical p-values
p_theory <- 2 * pnorm(q = -abs(z_star), lower.tail = TRUE)
p_camp <- lowmoi:::compute_empirical_p_value(z_star = z_star, z_null = z_null, "both")
# finally, compute permutation
ts <- lowmoi:::low_level_permutation_test(y = y, index_mat = idx_mat)
t_star <- ts[1]
t_null <- ts[-1]
p_perm <- lowmoi:::compute_empirical_p_value(t_star, t_null, "both")
out_m[i,] <- c(p_theory = p_theory, p_camp = p_camp, p_perm = p_perm)
if (i == 1) {
resamp_dist[["camp_null"]] <- z_null
resamp_dist[["camp_star"]] <- z_star
resamp_dist[["perm_null"]] <- ts
resamp_dist[["perm_star"]] <- t_star
}
}
colnames(out_m) <- c("p_theory", "p_camp", "p_perm")
return(list(out_m = out_m, resamp_dist = resamp_dist))
}
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
n_sim <- 2000
set.seed(3)
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# keep x fixed
x_idx <- which(orig_x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(orig_x), size = sum(orig_x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
# run sim
sim_res_correlated_corret_model <- run_simulation(Y = Y, idx_mat = idx_mat,
Z = Z, theta_hypothesized = theta,
return_null_dist = TRUE, approx = FALSE)
sceptre2:::run_glm_perm_score_test_with_ingredients
#################################
# STEP 2: RUN SIMULATION FUNCTION
#################################
run_simulation <- function(Y, idx_mat, Z, theta_hypothesized, n_sim = NULL, return_null_dist = FALSE, approx = TRUE) {
resamp_dist <- list()
if (is.null(n_sim)) n_sim <- ncol(Y)
out_m <- matrix(nrow = n_sim, ncol = 3)
for (i in seq(1, n_sim)) {
print(paste0("Running simulation ", i))
y <- Y[,i]
# regress the synthetic Y onto Z
fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta_hypothesized))
# extract z-scores
if (i == 1 || !approx) {
z_scores <- sceptre2:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- sceptre2:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
# compute theoretical and empirical p-values
p_theory <- 2 * pnorm(q = -abs(z_star), lower.tail = TRUE)
p_camp <- lowmoi:::compute_empirical_p_value(z_star = z_star, z_null = z_null, "both")
# finally, compute permutation
ts <- lowmoi:::low_level_permutation_test(y = y, index_mat = idx_mat)
t_star <- ts[1]
t_null <- ts[-1]
p_perm <- lowmoi:::compute_empirical_p_value(t_star, t_null, "both")
out_m[i,] <- c(p_theory = p_theory, p_camp = p_camp, p_perm = p_perm)
if (i == 1) {
resamp_dist[["camp_null"]] <- z_null
resamp_dist[["camp_star"]] <- z_star
resamp_dist[["perm_null"]] <- ts
resamp_dist[["perm_star"]] <- t_star
}
}
colnames(out_m) <- c("p_theory", "p_camp", "p_perm")
return(list(out_m = out_m, resamp_dist = resamp_dist))
}
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
n_sim <- 2000
set.seed(3)
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# keep x fixed
x_idx <- which(orig_x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(orig_x), size = sum(orig_x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
# run sim
sim_res_correlated_corret_model <- run_simulation(Y = Y, idx_mat = idx_mat,
Z = Z, theta_hypothesized = theta,
return_null_dist = TRUE, approx = FALSE)
sceptre2:::low_level_permutation_test
source("~/.Rprofile")
library(ondisc)
library(sceptre2)
result_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/extra_analyses/")
###########################
# STEP 1: SET UP SIMULATION
###########################
# 1. load Papalexi data
response_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/gene")
grna_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/grna_assignment")
grna_targets <- lowmoi::get_target_assignments_via_max_op(grna_odm)
# 2. get the gRNA group info
my_grna <- "CUL3"
grna_group_info <- sceptre2:::get_grna_group_info(grna_group_assignments = grna_targets,
input_grna_groups = my_grna)
idxs <- c(grna_group_info$grna_specific_idxs[[my_grna]],
grna_group_info$grna_specific_idxs[["non-targeting"]])
orig_x <- c(rep(1, grna_group_info$n_cells_per_grna[[my_grna]]),
rep(0, grna_group_info$n_cells_per_grna[["non-targeting"]]))
# 3. get covariate matrix
covariate_matrix_df <- response_odm |>
get_cell_covariates() |>
dplyr::slice(idxs) |>
dplyr::select(n_nonzero, n_umis, bio_rep, phase, p_mito)
row.names(covariate_matrix_df) <- NULL
Z <- model.matrix(object = formula(~ log(n_nonzero) + log(n_umis) + bio_rep + phase + p_mito),
data = covariate_matrix_df)
colnames(Z) <- c("intercept", "lg_n_nonzero", "lg_n_umis", "bio_rep_d1", "bio_rep_d2", "phase_d1", "phase_d2", "p_mito")
# 4. select gene
ex_gene <- "CXCL10"
orig_y <- as.numeric(response_odm[[ex_gene, idxs]])
# 5. get the model for y | Z
fit_y_orig <- MASS::glm.nb(formula = orig_y ~ . + 0, data = as.data.frame(Z))
y_coef <- coef(fit_y_orig)
theta <- fit_y_orig$theta
mus_y <- exp(as.numeric(Z %*% y_coef))
#################################
# STEP 2: RUN SIMULATION FUNCTION
#################################
run_simulation <- function(Y, idx_mat, Z, theta_hypothesized, n_sim = NULL, return_null_dist = FALSE, approx = TRUE) {
resamp_dist <- list()
if (is.null(n_sim)) n_sim <- ncol(Y)
out_m <- matrix(nrow = n_sim, ncol = 3)
for (i in seq(1, n_sim)) {
print(paste0("Running simulation ", i))
y <- Y[,i]
# regress the synthetic Y onto Z
fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta_hypothesized))
# extract z-scores
if (i == 1 || !approx) {
z_scores <- sceptre2:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- sceptre2:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
# compute theoretical and empirical p-values
p_theory <- 2 * pnorm(q = -abs(z_star), lower.tail = TRUE)
p_camp <- sceptre2:::compute_empirical_p_value(z_star = z_star, z_null = z_null, "both")
# finally, compute permutation
ts <- sceptre2:::low_level_permutation_test(y = y, index_mat = idx_mat)
t_star <- ts[1]
t_null <- ts[-1]
p_perm <- sceptre2:::compute_empirical_p_value(t_star, t_null, "both")
out_m[i,] <- c(p_theory = p_theory, p_camp = p_camp, p_perm = p_perm)
if (i == 1) {
resamp_dist[["camp_null"]] <- z_null
resamp_dist[["camp_star"]] <- z_star
resamp_dist[["perm_null"]] <- ts
resamp_dist[["perm_star"]] <- t_star
}
}
colnames(out_m) <- c("p_theory", "p_camp", "p_perm")
return(list(out_m = out_m, resamp_dist = resamp_dist))
}
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
n_sim <- 2000
set.seed(3)
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# keep x fixed
x_idx <- which(orig_x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(orig_x), size = sum(orig_x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
# run sim
sim_res_correlated_corret_model <- run_simulation(Y = Y, idx_mat = idx_mat,
Z = Z, theta_hypothesized = theta,
return_null_dist = TRUE, approx = FALSE)
###################################################
# STEP 4: CORRELATED AND MODEL MISSPECIFICATION SIM
###################################################
sim_res_correlated_misspec <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized =  5 * theta,
return_null_dist = TRUE, approx = FALSE)
#########################################
# STEP 6: UNCORRELATED, GLM INCORRECT SIM
#########################################
# keep y from above
# generate x fresh
x <- rbinom(n = length(orig_x), size = 1, prob = mean(orig_x))
x_idx <- which(x == 1)
x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
# run sim
sim_res_uncorrelated_misspec <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = 5 * theta,
return_null_dist = TRUE, approx = FALSE)
#######################################
# STEP 7: UNCORRELATED, GLM CORRECT SIM
#######################################
# run sim
sim_res_uncorrelated_correct_model <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = theta,
return_null_dist = TRUE, approx = FALSE)
#######################################
# STEP 7: UNCORRELATED, GLM CORRECT SIM
#######################################
# run sim
sim_res_uncorrelated_correct_model <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = theta,
return_null_dist = TRUE, approx = FALSE)
source("~/.Rprofile")
####################################################################
# The purpose of figures s8 and s9 is to compare the score statistic
# against the residual test statistic on real and simulated data.
####################################################################
# load packages
library(tidyverse); conflicts_prefer(dplyr::filter)
library(katlabutils)
library(cowplot)
# set file paths, load results, source helpers
source(paste0(.get_config_path("LOCAL_CODE_DIR"),
"sceptre2-manuscript/R_scripts/figure_creation/shared_figure_script.R"))
sceptre2_dir <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
############################
# PLOT 1: SIMULATION RESULTS
############################
# load simulation results, do basic preprocessing
simulation_result_fps <- paste0(sceptre2_dir, "results/extra_analyses/resid_vs_score_sim/") |> list.files(full.names = TRUE)
result_df <- lapply(X = seq_along(simulation_result_fps), FUN = function(i) {
fp <- simulation_result_fps[i]
readRDS(fp) |> mutate(proc_id = i)
}) |> data.table::rbindlist() |>
mutate(label = ifelse(null_true, "Null true", "Alternative true"))
# apply BH, and obtain the mean false discovery proportion (fdr-hat) across datasets
fdr_level <- 0.1
cols <- c("deepskyblue4", "firebrick2")
n_nonnull <- result_df |>
filter(proc_id == 1) |>
summarize(sum(label == "Alternative true")) |>
pull()
stat_summary_df <- result_df |> select(p_resid, p_score, p_lrt, null_true, proc_id) |>
pivot_longer(cols = c("p_resid", "p_score", "p_lrt"),
names_to = "method", values_to = "p_val") |>
group_by(method, proc_id) |>
mutate(p_adj = p.adjust(p_val, method = "BH"), signif = p_adj < fdr_level) |>
filter(signif) |>
summarize(n_total_discoveries = dplyr::n(),
n_false_discoveries = sum(null_true),
fdp = n_false_discoveries/n_total_discoveries)
stat_summary_df |> dplyr::filter(proc_id == 7)
stat_summary_df |> summarize(mean_fdp = mean(fdp),
mean_n_discoveries = mean(n_total_discoveries))
time_summary_df <- result_df |> select(resid_time, score_time, lrt_time) |>
pivot_longer(cols = c("resid_time", "score_time", "lrt_time"),
names_to = "method", values_to = "time") |>
group_by(method) |>
summarize(m_time = mean(time),
upper_ci = m_time + 1.96 * sd(time)/sqrt(dplyr::n()),
lower_ci = m_time - 1.96 * sd(time)/sqrt(dplyr::n()))
# create plot from one run
curr_proc_id <- 7
simulation_result <- result_df |>
filter(proc_id == curr_proc_id) |>
mutate(p_resid_trans = -log(p_resid, 10),
p_score_trans = -log(p_score, 10),
p_lrt_trans = -log(p_lrt, 10))
my_breaks <- 10^(seq(from = 0, to = -6, by = -2))
fit_1 <- lm(p_lrt_trans ~ p_resid_trans, data = simulation_result)
p1 <- ggplot(simulation_result, aes(x = p_resid, y = p_lrt, col = label)) +
geom_point(size = 0.9) +
theme_bw() +
scale_x_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
scale_y_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
geom_abline(slope = 1, intercept = 0) +
xlab("p (perm. residual statistic)") +
ylab("p (GLM-based LRT)") +
scale_color_manual(values = cols) + my_theme_no_legend +
geom_abline(intercept = fit_1$coefficients[1], slope = fit_1$coefficients[2],
col = "darkorange", linetype = "dashed")
fit_2 <- lm(p_lrt_trans ~ p_score_trans, data = simulation_result)
p2 <- ggplot(simulation_result, aes(x = p_score, y = p_lrt, col = label)) +
geom_point(size = 0.9) +
theme_bw() +
scale_x_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
scale_y_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
geom_abline(slope = 1, intercept = 0) +
xlab("p (perm. score statistic)") +
ylab("p (GLM-based LRT)") +
scale_color_manual(values = cols) + my_theme +
geom_abline(intercept = fit_2$coefficients[1], slope = fit_2$coefficients[2],
col = "darkorange", linetype = "dashed") +
theme(strip.background = element_blank(),
legend.title = element_blank(),
legend.position = c(0.7, 0.1),
legend.key.size = unit(0.35, 'cm'),
legend.margin = margin(t = -0.5, unit = 'cm'),
axis.title.y = element_text(margin = margin(t = 0, r = 15, b = 0, l = 0)))
fit_3 <- lm(p_score_trans ~ p_resid_trans, data = simulation_result)
p3 <- ggplot(simulation_result, aes(x = p_resid, y = p_score, col = label)) +
geom_point(size = 0.9) +
theme_bw() +
scale_x_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
scale_y_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
geom_abline(slope = 1, intercept = 0) +
xlab("p (perm. residual statistic)") +
ylab("p (perm. score statistic)") +
scale_color_manual(values = cols) + my_theme_no_legend +
geom_abline(intercept = fit_3$coefficients[1], slope = fit_3$coefficients[2],
col = "darkorange", linetype = "dashed")
p4 <- ggplot() + theme_minimal()
p_final <- plot_grid(plot_grid(p1, p2, p3, p4, nrow = 2, labels = "auto"))
p_final
