calibration_check = TRUE,
response_grna_group_pairs = gene_grna_group_pairs)
result_3 <- sceptre3::run_sceptre_lowmoi(response_matrix = response_matrix,
grna_matrix = grna_matrix,
covariate_data_frame = covariate_data_frame,
grna_group_data_frame = grna_group_data_frame,
formula_object = gene_formula,
calibration_check = FALSE,
response_grna_group_pairs = gene_grna_group_pairs)
result_3 <- sceptre3::run_sceptre_lowmoi(response_matrix = response_matrix,
grna_matrix = grna_matrix,
covariate_data_frame = covariate_data_frame,
grna_group_data_frame = grna_group_data_frame,
formula_object = gene_formula,
calibration_check = TRUE,
response_grna_group_pairs = gene_grna_group_pairs)
n_nonzero_trt_thresh = 7L
n_nonzero_cntrl_thresh = 7L; return_debugging_metrics = FALSE
return_resampling_dist = FALSE; fit_skew_normal = TRUE
calibration_group_size = NULL; n_calibration_pairs = NULL
test_stat = "full", B1 = 499L; B2 = 4999L; B3 = 24999L
n_nonzero_trt_thresh = 7L
n_nonzero_cntrl_thresh = 7L; return_debugging_metrics = FALSE
return_resampling_dist = FALSE; fit_skew_normal = TRUE
calibration_group_size = NULL; n_calibration_pairs = NULL
test_stat = "full"; B1 = 499L; B2 = 4999L; B3 = 24999L
print_progress = TRUE
dim(response_matrix)
response_matrix[1:5,1:5]
grna_matrix[1:5,1:5]
head(covariate_data_frame)
head(grna_group_data_frame)
formula_object
###############
# PART 1: SETUP
###############
cat("Running setup. ")
# 1. check function input arguments
check_inputs(response_matrix, grna_matrix, covariate_data_frame, grna_group_data_frame,
formula_object, calibration_check, response_grna_group_pairs, test_stat) |> invisible()
load_all("~/research_code/sceptre3/")
# 1. check function input arguments
check_inputs(response_matrix, grna_matrix, covariate_data_frame, grna_group_data_frame,
formula_object, calibration_check, response_grna_group_pairs, test_stat) |> invisible()
response_grna_group_pairs = gene_grna_group_pairs
calibration_check = TRUE
formula_object = gene_formula
###############
# PART 1: SETUP
###############
cat("Running setup. ")
# 1. check function input arguments
check_inputs(response_matrix, grna_matrix, covariate_data_frame, grna_group_data_frame,
formula_object, calibration_check, response_grna_group_pairs, test_stat) |> invisible()
head(response_id)
response_grna_group_pairs$response_id
response_matrix |> dim()
nrow(response_grna_group_pairs)
head(response_grna_group_pairs$response_id)
response_grna_group_pairs$response_id
all(response_grna_group_pairs$response_id %in% rownames(response_matrix))
response_matrix[1:5,1:5]
grna_matrix[1:5,1:5]
head(covariate_data_frame)
head(grna_group_data_frame)
formula_object
calibration_check
response_grna_group_pairs
test_stat
# 1. check column names of grna_group_data_frame
colnames_present <- all(c("grna_id", "grna_group") %in% colnames(grna_group_data_frame))
if (!colnames_present) {
stop("The data frame `grna_group_data_frame` must have columns `grna_id` and `grna_group`. The `grna_group` column should specify the group to which each `grna_id` belongs.")
}
# 2. check for the presence of "non-targeting" in the grna_group column
nt_present <- "non-targeting" %in% grna_group_data_frame$grna_group
if (!nt_present) {
stop(paste0("The string 'non-targeting' must be present in the `grna_group` column of the `grna_group_data_frame`."))
}
# 3. verify that the row names are unique for both response and grna modalities
response_ids <- rownames(response_matrix)
grna_ids <- rownames(grna_matrix)
if (length(response_ids) != length(unique(response_ids))) stop("The rownames of the `response_matrix` must be unique.")
if (length(grna_ids) != length(unique(grna_ids))) stop("The rownames of the `grna_matrix` must be unique.")
# 4. ensure that the ampersand symbol (&) is absent from the grna ids; ensure that no gRNA is named "non-targeting"
problematic_grna_ids <- grep(pattern = "&", x = grna_ids)
if (length(problematic_grna_ids) >= 1) {
stop(paste0("The ampersand character (&) cannot be present in the gRNA IDs. The following gRNA IDs contain an ampersand: ", paste0(grna_ids[problematic_grna_ids], collapse = ", ")))
}
if (any(grna_ids == "non-targeting")) {
stop("No individual gRNA can have the ID `non-targeting`. The string `non-targeting` is reserved for the `grna_group` column of the `grna_group_data_frame`.")
}
# 5. if the pairs to analyze have been specified...
# i. verify that `grna_group` and `response_id` are columns
all(c("grna_group", "response_id") %in% colnames(response_grna_group_pairs))
# ii. check that the response ids in the `response_grna_group_pairs` data frame are a subset of the response ids
if (!all(response_grna_group_pairs$response_id %in% response_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
# iii. check that the grna ids in the  `grna_group_data_frame` data frame are a subset of the grna ids
if (!all(grna_group_data_frame$grna_id %in% grna_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
# iv. check that the `grna_group` column of the `response_grna_group_pairs` data frame is a subset of the `grna_group` column of the `grna_group_data_frame`
if (!all(response_grna_group_pairs$grna_group %in% grna_group_data_frame$grna_group)) {
stop("The column `grna_group` of the `response_grna_group_pairs` data frame must be a subset of the colummn `grna_group` of the `grna_group_data_frame`.")
}
# 5. if the pairs to analyze have been specified...
# i. verify that `grna_group` and `response_id` are columns
all(c("grna_group", "response_id") %in% colnames(response_grna_group_pairs))
# ii. check that the response ids in the `response_grna_group_pairs` data frame are a subset of the response ids
if (!all(response_grna_group_pairs$response_id %in% response_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
# iii. check that the grna ids in the  `grna_group_data_frame` data frame are a subset of the grna ids
if (!all(grna_group_data_frame$grna_id %in% grna_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
grna_ids
rownames(grna_matrix)
gnra_ma
grna_matrix
rownames(grna_matrix)
31000/30000
# 5. if the pairs to analyze have been specified...
# i. verify that `grna_group` and `response_id` are columns
all(c("grna_group", "response_id") %in% colnames(response_grna_group_pairs))
# ii. check that the response ids in the `response_grna_group_pairs` data frame are a subset of the response ids
if (!all(response_grna_group_pairs$response_id %in% response_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
# iii. check that the grna ids in the  `grna_group_data_frame` data frame are a subset of the grna ids
if (!all(grna_group_data_frame$grna_id %in% grna_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
# iv. check that the `grna_group` column of the `response_grna_group_pairs` data frame is a subset of the `grna_group` column of the `grna_group_data_frame`
if (!all(response_grna_group_pairs$grna_group %in% grna_group_data_frame$grna_group)) {
stop("The column `grna_group` of the `response_grna_group_pairs` data frame must be a subset of the colummn `grna_group` of the `grna_group_data_frame`.")
}
# 5. if the pairs to analyze have been specified...
# i. verify that `grna_group` and `response_id` are columns
all(c("grna_group", "response_id") %in% colnames(response_grna_group_pairs))
# ii. check that the response ids in the `response_grna_group_pairs` data frame are a subset of the response ids
if (!all(response_grna_group_pairs$response_id %in% response_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
# iii. check that the grna ids in the  `grna_group_data_frame` data frame are a subset of the grna ids
if (!all(grna_group_data_frame$grna_id %in% grna_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
!all(grna_group_data_frame$grna_id %in% grna_ids)
# ii. check that the response ids in the `response_grna_group_pairs` data frame are a subset of the response ids
if (!all(response_grna_group_pairs$response_id %in% response_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
# iii. check that the grna ids in the  `grna_group_data_frame` data frame are a subset of the grna ids
if (!all(grna_group_data_frame$grna_id %in% grna_ids)) {
stop("The column `response_id` of the `response_grna_group_pairs` data frame must be a subset of the row names of the response modality expression matrix.")
}
rownames(grna_ids)
load_all("~/research_code/sceptre2/")
load_all("~/research_code/sceptre3/")
library(ondisc) # devtools::install_github('timothy-barry/ondisc')
library(sceptre3)
library(BH)
# This script uses sceptre3 to run an approximate undercover analysis on the
LOCAL_SCEPTRE2_DATA_DIR <-.get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
papalexi_dir <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/papalexi/eccite_screen/")
# gene info
gene_odm_fp <- paste0(papalexi_dir, "gene/matrix.odm")
# grna info
grna_odm_fp <- paste0(papalexi_dir, "grna_expression/matrix.odm")
# mm odm metadata fp
mm_metadata_fp <- paste0(papalexi_dir, "multimodal_metadata.rds")
# construct mm odm
mm_odm <- ondisc::read_multimodal_odm(odm_fps = c(gene_odm_fp, grna_odm_fp),
multimodal_metadata_fp = mm_metadata_fp)
# get the in-memory gene matrix
gene_odm <- mm_odm |> ondisc::get_modality("gene")
response_matrix <- gene_odm[[seq(1, nrow(gene_odm)),]]
rownames(response_matrix) <- ondisc::get_feature_ids(gene_odm)
# get the in-memory grna matrix
grna_odm <- mm_odm |> ondisc::get_modality("grna_expression")
grna_matrix <- grna_odm[[seq(1, nrow(grna_odm)),]]
rownames(grna_matrix) <- ondisc::get_feature_ids(grna_odm)
# covariate matrix
covariate_data_frame <- mm_odm |> ondisc::get_cell_covariates()
# grna group data frame
grna_group_data_frame <- data.frame(grna_id = rownames(grna_odm@feature_covariates),
grna_group = grna_odm@feature_covariates$target)
# set formulas, grna group target name
gene_formula <- ~ log(gene_n_umis) + log(gene_n_nonzero) + bio_rep + p_mito
undercover_result <- sceptre3::run_sceptre_lowmoi(response_matrix = response_matrix,
grna_matrix = grna_matrix,
covariate_data_frame = covariate_data_frame,
grna_group_data_frame = grna_group_data_frame,
formula_object = gene_formula,
calibration_check = TRUE,
response_grna_group_pairs = NULL,
test_stat = "full",
return_resampling_dist = FALSE,
fit_skew_normal = TRUE,
B1 = 500,
B2 = 5000,
B3 = 25000,
undercover_group_size = 1,
n_calibration_pairs = 9 * nrow(response_matrix))
undercover_result <- sceptre3::run_sceptre_lowmoi(response_matrix = response_matrix,
grna_matrix = grna_matrix,
covariate_data_frame = covariate_data_frame,
grna_group_data_frame = grna_group_data_frame,
formula_object = gene_formula,
calibration_check = TRUE,
response_grna_group_pairs = NULL,
test_stat = "full",
return_resampling_dist = FALSE,
fit_skew_normal = TRUE,
B1 = 500,
B2 = 5000,
B3 = 25000,
undercover_group_size = 1,
n_calibration_pairs = 9 * nrow(response_matrix))
undercover_result <- sceptre3::run_sceptre_lowmoi(response_matrix = response_matrix,
grna_matrix = grna_matrix,
covariate_data_frame = covariate_data_frame,
grna_group_data_frame = grna_group_data_frame,
formula_object = gene_formula,
calibration_check = TRUE,
response_grna_group_pairs = NULL,
test_stat = "full",
return_resampling_dist = FALSE,
fit_skew_normal = TRUE,
B1 = 500,
B2 = 5000,
B3 = 25000,
calibration_group_size = 1,
n_calibration_pairs = 9 * nrow(response_matrix))
undercover_result <- sceptre3::run_sceptre_lowmoi(response_matrix = response_matrix,
grna_matrix = grna_matrix,
covariate_data_frame = covariate_data_frame,
grna_group_data_frame = grna_group_data_frame,
formula_object = gene_formula,
calibration_check = TRUE,
response_grna_group_pairs = NULL,
test_stat = "full",
return_resampling_dist = FALSE,
fit_skew_normal = TRUE,
B1 = 500,
B2 = 5000,
B3 = 25000,
calibration_group_size = 1,
n_calibration_pairs = 9 * nrow(response_matrix))
head(response_grna_group_pairs)
response_matrix = response_matrix
grna_matrix = grna_matrix
covariate_data_frame = covariate_data_frame
grna_group_data_frame = grna_group_data_frame
formula_object = gene_formula
calibration_check = TRUE
response_grna_group_pairs = NULL
test_stat = "full"
return_resampling_dist = FALSE
fit_skew_normal = TRUE
B1 = 500
B2 = 5000
B3 = 25000
calibration_group_size = 1
n_calibration_pairs = 9 * nrow(response_matrix)
undercover_result <- sceptre3::run_sceptre_lowmoi(response_matrix = response_matrix,
grna_matrix = grna_matrix,
covariate_data_frame = covariate_data_frame,
grna_group_data_frame = grna_group_data_frame,
formula_object = gene_formula,
calibration_check = TRUE,
response_grna_group_pairs = NULL,
test_stat = "full",
return_resampling_dist = FALSE,
fit_skew_normal = TRUE,
B1 = 500,
B2 = 5000,
B3 = 25000,
calibration_group_size = 1,
n_calibration_pairs = 9 * nrow(response_matrix))
LOCAL_SCEPTRE2_DATA_DIR <-.get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
papalexi_dir <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/papalexi/eccite_screen/")
# gene info
gene_odm_fp <- paste0(papalexi_dir, "gene/matrix.odm")
# grna info
grna_odm_fp <- paste0(papalexi_dir, "grna_expression/matrix.odm")
# mm odm metadata fp
mm_metadata_fp <- paste0(papalexi_dir, "multimodal_metadata.rds")
# construct mm odm
mm_odm <- ondisc::read_multimodal_odm(odm_fps = c(gene_odm_fp, grna_odm_fp),
multimodal_metadata_fp = mm_metadata_fp)
# get the in-memory gene matrix
gene_odm <- mm_odm |> ondisc::get_modality("gene")
response_matrix <- gene_odm[[seq(1, nrow(gene_odm)),]]
rownames(response_matrix) <- ondisc::get_feature_ids(gene_odm)
# get the in-memory grna matrix
grna_odm <- mm_odm |> ondisc::get_modality("grna_expression")
grna_matrix <- grna_odm[[seq(1, nrow(grna_odm)),]]
rownames(grna_matrix) <- ondisc::get_feature_ids(grna_odm)
# covariate matrix
covariate_data_frame <- mm_odm |> ondisc::get_cell_covariates()
# grna group data frame
grna_group_data_frame <- data.frame(grna_id = rownames(grna_odm@feature_covariates),
grna_group = grna_odm@feature_covariates$target)
# set formulas, grna group target name
gene_formula <- ~ log(gene_n_umis) + log(gene_n_nonzero) + bio_rep + p_mito
grna_group <- "target"
# set hyperparameters
B <- 25000
side <- "both"
max_b_per_batch <- 25000
in_memory <- TRUE
statistic <- "full" # "distilled" is faster but might be less powerful
return_dist <- FALSE
screen_b <- 500
# select gene-gRNA group pairs to analyze
gene_grna_group_pairs <- expand.grid(response_id = mm_odm |>
ondisc::get_modality("gene") |>
ondisc::get_feature_ids(),
grna_group = c("CUL3")) |> dplyr::sample_n(100)
head(gene_grna_group_pairs)
result_3 <- sceptre3::run_sceptre_lowmoi(response_matrix = response_matrix,
grna_matrix = grna_matrix,
covariate_data_frame = covariate_data_frame,
grna_group_data_frame = grna_group_data_frame,
formula_object = gene_formula,
calibration_check = FALSE,
response_grna_group_pairs = gene_grna_group_pairs)
result_3
response_matrix = response_matrix
grna_matrix = grna_matrix
covariate_data_frame = covariate_data_frame
grna_group_data_frame = grna_group_data_frame
formula_object = gene_formula
calibration_check = FALSE
response_grna_group_pairs = gene_grna_group_pairs
n_nonzero_trt_thresh = 7L
n_nonzero_cntrl_thresh = 7L; return_debugging_metrics = FALSE
return_resampling_dist = FALSE; fit_skew_normal = TRUE
calibration_group_size = NULL; n_calibration_pairs = NULL
test_stat = "full"; B1 = 499L; B2 = 4999L; B3 = 24999L
print_progress = TRUE
###############
# PART 1: SETUP
###############
cat("Running setup. ")
# 1. check function input arguments
check_inputs(response_matrix, grna_matrix, covariate_data_frame, grna_group_data_frame,
formula_object, calibration_check, response_grna_group_pairs, test_stat) |> invisible()
load_all("~/research_code/sceptre3/")
###############
# PART 1: SETUP
###############
cat("Running setup. ")
# 1. check function input arguments
check_inputs(response_matrix, grna_matrix, covariate_data_frame, grna_group_data_frame,
formula_object, calibration_check, response_grna_group_pairs, test_stat) |> invisible()
# 2. harmonize arguments (called for side-effect)
harmonize_arguments(return_resampling_dist, fit_skew_normal, test_stat) |> invisible()
# 3. cast and transpose response matrix; cast grna matrix
response_matrix <- set_matrix_accessibility(response_matrix, TRUE)
# 4. convert the cell covariate data frame into a design matrix
covariate_matrix <- convert_covariate_df_to_design_matrix(covariate_data_frame, formula_object)
rm(covariate_data_frame)
# 5. assign the gRNAs to cells
grna_assignments <- assign_grnas_to_cells_lowmoi_v2(grna_matrix, grna_group_data_frame, calibration_check, n_calibration_pairs)
rm(grna_matrix)
cat(crayon::green(' \u2713\n'))
# 6. construct the undercover response_grna_group_pairs
if (calibration_check) {
cat("Constructing negative control pairs.")
if (is.null(calibration_group_size)) calibration_group_size <- compute_calibration_group_size(grna_group_data_frame)
response_grna_group_pairs <- construct_negative_control_pairs(n_calibration_pairs, calibration_group_size, grna_assignments, response_matrix, n_nonzero_trt_thresh, n_nonzero_cntrl_thresh, grna_group_data_frame, response_grna_group_pairs)
cat(crayon::green(' \u2713\n'))
}
# 7. generate the set of synthetic indicator idxs
cat("Generating permutation resamples.")
synthetic_idxs <- get_synthetic_idxs_lowmoi(grna_assignments, B1 + B2 + B3, calibration_check, calibration_group_size)
cat(crayon::green(' \u2713\n'))
gc() |> invisible()
####################
# PART 2: RUN METHOD
####################
cat("Running differential expression analyses.\n")
ret <- run_lowmoi_in_memory(response_matrix, grna_assignments,
covariate_matrix, response_grna_group_pairs,
synthetic_idxs, full_test_stat,
return_resampling_dist, fit_skew_normal,
B1, B2, B3, calibration_check,
n_nonzero_trt_thresh, n_nonzero_cntrl_thresh,
return_debugging_metrics, print_progress)
# 0. preliminary setup; initialize the args_to_pass, set the low_level_association_funct
result_list_outer <- vector(mode = "list", length = 2 * length(unique(response_grna_group_pairs$response_id)))
out_counter <- 1L
args_to_pass <- list(synthetic_idxs = synthetic_idxs,
B1 = B1, B2 = B2, B3 = B3,
fit_skew_normal = fit_skew_normal,
return_resampling_dist = return_resampling_dist)
if (calibration_check) {
args_to_pass$indiv_nt_grna_idxs <- grna_assignments$indiv_nt_grna_idxs
} else {
args_to_pass$grna_group_idxs <- grna_assignments$grna_group_idxs
args_to_pass$covariate_matrix <- covariate_matrix
}
low_level_association_funct <- if (!calibration_check & full_test_stat) {
"lowmoi_full_stat_discovery"
} else if (!calibration_check & !full_test_stat) {
"lowmoi_distilled_stat_discovery"
} else if (calibration_check & full_test_stat) {
"lowmoi_full_stat_undercover"
} else {
"lowmoi_distilled_stat_undercover"
}
# 1. obtain the subset of the covariate matrix corresponding to the NT cells and n_cells
covariate_matrix_nt <- covariate_matrix[grna_assignments$all_nt_idxs,]
n_cells <- response_matrix@Dim[2]
# 2. loop over the response IDs
response_ids <- unique(response_grna_group_pairs$response_id)
for (response_idx in seq_along(response_ids)) {
if ((response_idx == 1 || response_idx %% 5 == 0) && print_progress) {
cat(paste0("Analyzing pairs containing response ", as.character(response_ids[response_idx]), " (", response_idx, " of ", length(response_ids), ")\n"))
}
response_id <- as.character(response_ids[response_idx])
# 3. load the expressions of the current response
expression_vector <- load_csr_column(j = response_matrix@j,
p = response_matrix@p,
x = response_matrix@x,
column_idx = which(rownames(response_matrix) == response_id),
n_cells = n_cells)
expression_vector_nt <- expression_vector[grna_assignments$all_nt_idxs]
# 4. obtain the gRNA groups to analyze
l <- response_grna_group_pairs$response_id == response_id
curr_df <- response_grna_group_pairs[l,]
# 5. if running a discovery analysis, do QC
if (!calibration_check) {
n_nonzero_cntrl_curr <- sum(expression_vector_nt >= 1)
grna_group_posits <- match(x = curr_df$grna_group, table = names(grna_assignments$grna_group_idxs))
n_nonzero_trt_curr <- compute_n_nonzero_trt_vector(expression_vector = expression_vector,
grna_group_idxs = grna_assignments$grna_group_idxs,
grna_group_posits = grna_group_posits)
curr_df$n_nonzero_trt <- n_nonzero_trt_curr
curr_df$n_nonzero_cntrl <- n_nonzero_cntrl_curr
# i. if n_nonzero_cntrl_curr is less than n_nonzero_cntrl_thresh, jump to next iteration
if (n_nonzero_cntrl_curr < n_nonzero_cntrl_thresh) {
result_list_outer[[out_counter]] <- curr_df
out_counter <- out_counter + 1L
next
}
# ii. determine the gRNA groups that have passed qc
pass_qc <- n_nonzero_trt_curr >= n_nonzero_trt_thresh
# iii. remove any rows that have not passed qc; keep the rows that have passed qc
if (!all(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df[!pass_qc,]
out_counter <- out_counter + 1L
}
curr_df <- curr_df[pass_qc,]
}
# 6. perform the expression on technical factor regression
response_precomp <- perform_response_precomputation(expressions = expression_vector_nt,
covariate_matrix = covariate_matrix_nt)
# 7. obtain precomputation peices for NT cells
pieces_precomp <- compute_precomputation_pieces(expression_vector_nt,
covariate_matrix_nt,
response_precomp$fitted_coefs,
response_precomp$theta,
full_test_stat)
# 8. update the args to pass with grna_groups, expression_vector, response_precomp, pieces_precomp
args_to_pass$grna_groups <- as.character(curr_df$grna_group)
args_to_pass$pieces_precomp <- pieces_precomp
args_to_pass$expression_vector_nt <- expression_vector_nt
if (!calibration_check) {
args_to_pass$expression_vector <- expression_vector
args_to_pass$response_precomp <- response_precomp
}
# 9. pass the arguments to the appropriate low-level association testing function
curr_response_result <- do.call(what = low_level_association_funct, args = args_to_pass)
# 10. combine the response-wise results into a data table; insert into list
result_list_outer[[out_counter]] <- construct_data_frame_v2(curr_df, curr_response_result,
return_debugging_metrics, return_resampling_dist,
response_precomp$precomp_str)
out_counter <- out_counter + 1L
}
result_list_outer
# combine and sort result
ret <- data.table::rbindlist(result_list_outer, fill = TRUE)
ret
ret$p_value
ret$log_2_fold_change
ret$n_nonzero_cntrl
ret |> length()
out_counter
result_list_outer[[out_counter]]
result_list_outer[[out_counter - 1]]
result_list_outer[seq(1, out_counter)]
result_list_outer[seq(1, out_counter - 1)]
result_list_outer[seq(1, out_counter - 1L)]
ret <- data.table::rbindlist(result_list_outer[seq(1, out_counter - 1L)], fill = TRUE)
ret
result_list_outer[[1]]
result_list_outer[[2]]
result_list_outer[[3]]
result_list_outer[[4]]
result_list_outer[[5]]
result_list_outer[[6]]
result_list_outer[[7]]
result_list_outer[[8]]
result_list_outer[[9]]
result_list_outer[[10]]
result_list_outer[[11]]
