linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
p_plot
install.packages("ADGofTest")
library(ADGofTest)
ad.test(trun_data, "pgpd",  u_pos, sig_mom, xi_mom)
ad.test(trun_data, pgpd,  u_pos, sig_mom, xi_mom)
test_ks
# compute the ratio p-value
ratio_pvalue <- max(expected_tail_prob / observed_tail_prob,
observed_tail_prob / expected_tail_prob)
# compute the ratio p-value
ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
observed_tail_prob / gpd_tail_prob)
ratio_pvalue
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# method of moment
xi_mom <- (1 - (mean(trun_data) - u_pos)^2/var(trun_data))/2
sig_mom <- (mean(trun_data) - u_pos)*(1 - xi_mom)
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "pgpd", u_pos, sig_mom, xi_mom)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
if(is.nan(test_ks$p.value)){
sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
# k-s test
test_ks <- ks.test(trun_data, sim_data)
}
dgpd_density <- function(x) {
(1 - q) * dgpd(sign_flip*x,
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null^3)
} else{
x_min <- min(z_null^3)
x_max <- u
}
hist_full <- tibble(z_null^3) %>%
ggplot(aes(x = z_null^3)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
# plot the tail probability
observed_tail_prob <- (10:(0.1*n))/n
observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
gpd_tail_prob <- 1 - as.vector(pgpd(q = observed_extreme_quantile,
loc = u_pos,
scale = sig_mom,
shape = xi_mom))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
gpd_tail_prob = gpd_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
p_plot
idx <- 2
idx <- 2
q <- 0.96
samples <- 5e5
a <- 3
# extract percentile and no_samples
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
# extract percentile and no_samples
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
for(tail in c("left", "right")){
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)^a
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# method of moment
xi_mom <- (1 - (mean(trun_data) - u_pos)^2/var(trun_data))/2
sig_mom <- (mean(trun_data) - u_pos)*(1 - xi_mom)
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "pgpd", u_pos, sig_mom, xi_mom)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
if(is.nan(test_ks$p.value)){
sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
# k-s test
test_ks <- ks.test(trun_data, sim_data)
}
dgpd_density <- function(x) {
(1 - q) * dgpd(sign_flip*x,
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null^a)
} else{
x_min <- min(z_null^a)
x_max <- u
}
hist_full <- tibble(z_null^a) %>%
ggplot(aes(x = z_null^a)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
# plot the tail probability
observed_tail_prob <- (10:(0.1*n))/n
observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
gpd_tail_prob <- 1 - as.vector(pgpd(q = observed_extreme_quantile,
loc = u_pos,
scale = sig_mom,
shape = xi_mom))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
gpd_tail_prob = gpd_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
# store the plot
plots[[tail]] <- plot_grid(qq_plot,
p_plot,
ncol = 1,
rel_heights = c(1.5, 1.5),
align = "v")
# compute the ratio p-value
ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
observed_tail_prob / gpd_tail_prob)
}
plots
hist_full
# extract percentile and no_samples
for(tail in c("left", "right")){
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# method of moment
xi_mom <- (1 - (mean(trun_data) - u_pos)^2/var(trun_data))/2
sig_mom <- (mean(trun_data) - u_pos)*(1 - xi_mom)
if(xi_mom < 0){
xi_mom <- 0
}
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "pgpd", u_pos, sig_mom, xi_mom)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
if(is.nan(test_ks$p.value)){
sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
# k-s test
test_ks <- ks.test(trun_data, sim_data)
}
dgpd_density <- function(x) {
(1 - q) * dgpd(sign_flip*x,
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
# plot the tail probability
observed_tail_prob <- (10:(0.1*n))/n
observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
gpd_tail_prob <- 1 - as.vector(pgpd(q = observed_extreme_quantile,
loc = u_pos,
scale = sig_mom,
shape = xi_mom))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
gpd_tail_prob = gpd_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
# store the plot
plots[[tail]] <- plot_grid(qq_plot,
p_plot,
ncol = 1,
rel_heights = c(1.5, 1.5),
align = "v")
# compute the ratio p-value
ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
observed_tail_prob / gpd_tail_prob)
}
plots
hist(trun_data)
hist(z_null)
library(readr)
param <- read_csv("~/Documents/Projects/sceptre2/sceptre2-manuscript/writeups/resampling_distributions/low_moi_explore/figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv",
col_names = FALSE)
View(param)
param <- read_csv("figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv", col_names = FALSE)
param
param <- as.data.frame(param)
param
pram[,1]
pram[,1]
param[,1]
param[1,]
param <- as.data.frame(param[-1,-1])
param[,1]
param <- as.data.frame(as.numeric(param[-1,-1]))
param <- as.numeric(as.data.frame(param[-1,-1]))
param <- as.numeric(as.matrix(param[-1,-1]))
param <- read_csv("figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv", col_names = FALSE)
param <- as.numeric(as.matrix(param[-1,-1]))
param[,1]
param[1,]
dim(param)
as.matrix(param[-1,-1])
param <- read_csv("figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv", col_names = FALSE)
param[,1]
param[,2]
param <- as.matrix(as.data.frame(param[-1,-1]))
param[,1]
param <- as.numeric(as.matrix(as.data.frame(param[-1,-1])))
param[,1]
param <- read_csv("figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv", col_names = FALSE)
param <- as.numeric(as.matrix(as.data.frame(param[-1,-1])))
param[,1]
param <- read_csv("figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv", col_names = FALSE)
class(param)
param[[1]]
param[[2]]
length(param)
param <- read_csv("figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv", col_names = FALSE)
param_mat <- matrix(0,5,660)
for (i in 1:660) {
param_mat[,i] <- as.numeric(param[[i+1]])
}
param <- read_csv("figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv", col_names = FALSE)
for (i in 1:660) {
param_mat[,i] <- as.numeric(param[[i+1]][-1])
}
param_mat[,1]
param_mat[,2]
rownames(param_mat) <- c("location", "scale", "shape", "statistic", "p-value")
# compute the upper bound of GPD distribution
up_bd <- param_mat[1,] - param_mat[2,]/param_mat[3,]
up_bd
library(eva)
library(tidyverse)
library(katlabutils)
library(cowplot)
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
# load empirical distributions
resampling_dists <- readRDS(paste0(sceptre2_results_dir, "resampling_distributions/sceptre_resampling_dists.rds"))
# how many of resampling distributions exceeding the upper bound
u_max <- numeric(330)
for (idx in 1:330) {
z_null <- as.numeric(resampling_dists[idx,5:(4+5e5)])
u_max[idx] <- max(z_null)
}
# how many of resampling distributions exceeding the upper bound
u_max <- numeric(330)
# how many of resampling distributions exceeding the upper bound
u_max <- apply(as.numeric(resampling_dists[,5:(4+5e5)]), 1, max)
class(as.numeric(resampling_dists[,5:(4+5e5)]))
class(as.numeric(resampling_dists[,(5:(4+5e5))]))
class(as.numeric(resampling_dists[1,(5:(4+5e5))]))
max(as.numeric(resampling_dists[1,(5:(4+5e5))]))
# how many of resampling distributions exceeding the upper bound
u_max <- apply(as.matrix(as.numeric(resampling_dists[,(5:(4+5e5))])), 1, max)
# how many of resampling distributions exceeding the upper bound
u_max <- apply(as.data.frame(as.numeric(resampling_dists[,(5:(4+5e5))])), 1, max)
resampling_dists[1,(5:(4+5e5))]
resampling_dists[1,(5:(4+5))]
class(resampling_dists[1,(5:(4+5))])
as.matrix(resampling_dists[1,(5:(4+5))])
as.matrix(resampling_dists[1:4,(5:(4+5))])
as.matrix(resampling_dists[1:10,(5:(4+5))])
# how many of resampling distributions exceeding the upper bound
u_max <- apply(as.numeric(as.matrix(resampling_dists[,(5:(4+5e5))])), 1, max)
dim(as.numeric(as.matrix(resampling_dists[,(5:(4+5e5))])))
dim(as.matrix(resampling_dists[,(5:(4+5e5))]))
# how many of resampling distributions exceeding the upper bound
u_max <- apply(as.matrix(resampling_dists[,(5:(4+5e5))]), 1, max)
u_max
which(up_bd[331:660] - u_max < 0)
u_min <- apply(as.matrix(resampling_dists[,(5:(4+5e5))]), 1, min)
which(up_bd[1:330] + u_min < 0)
idx <- 2
q <- 0.96
samples <- 5e5
a <- 3
# extract percentile and no_samples
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
# extract percentile and no_samples
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
for(tail in c("left", "right")){
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)^a
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# method of moment
xi_mom <- (1 - (mean(trun_data) - u_pos)^2/var(trun_data))/2
sig_mom <- (mean(trun_data) - u_pos)*(1 - xi_mom)
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "pgpd", u_pos, sig_mom, xi_mom)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
if(is.nan(test_ks$p.value)){
sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
# k-s test
test_ks <- ks.test(trun_data, sim_data)
}
dgpd_density <- function(x) {
(1 - q) * dgpd(sign_flip*x,
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null^a)
} else{
x_min <- min(z_null^a)
x_max <- u
}
hist_full <- tibble(z_null^a) %>%
ggplot(aes(x = z_null^a)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
loc = u_pos,
scale = sig_mom,
shape = xi_mom)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
# plot the tail probability
observed_tail_prob <- (10:(0.1*n))/n
observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
gpd_tail_prob <- 1 - as.vector(pgpd(q = observed_extreme_quantile,
loc = u_pos,
scale = sig_mom,
shape = xi_mom))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
gpd_tail_prob = gpd_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
# store the plot
plots[[tail]] <- plot_grid(qq_plot,
p_plot,
ncol = 1,
rel_heights = c(1.5, 1.5),
align = "v")
# compute the ratio p-value
ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
observed_tail_prob / gpd_tail_prob)
}
plots
hist_full <- tibble(z_null^a) %>%
ggplot(aes(x = z_null^a)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_full
hist_full <- tibble(z_null^a) %>%
ggplot(aes(x = z_null^a)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
coord_cartesian(xlim = c(-10, 10)) +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_full
up_bd
# find the instances where gpd does not cover the whole resamples support
which(up_bd[331:660] - u_max < 0)
resampling_dists[2,1:5]
knitr::opts_chunk$set(echo = TRUE)
library(eva)
library(tidyverse)
library(katlabutils)
library(cowplot)
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
# load empirical distributions
resampling_dists <- readRDS(paste0(sceptre2_results_dir, "resampling_distributions/sceptre_resampling_dists.rds"))
resampling_dists[1:5, 1:6]
