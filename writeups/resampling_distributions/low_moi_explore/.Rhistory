gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
cov <- t(Z) %*% cov_gZ / n
cov
solve(cov)
n <- 5000
q <- 50
s <- 5
nu <- 0.1
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- sample(3, n, replace = TRUE, prob = c(0.6, 0.2, 0.2)) - 1.6
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 5000
q <- 50
s <- 5
nu <- 0.1
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- sample(3, n, replace = TRUE, prob = c(0.6, 0.2, 0.2)) - 1.6
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j]
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
g_Z
n <- 5000
q <- 50
s <- 5
nu <- 2
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- sample(3, n, replace = TRUE, prob = c(0.6, 0.2, 0.2)) - 1.6
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 4
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- sample(3, n, replace = TRUE, prob = c(0.6, 0.2, 0.2)) - 1.6
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 2
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- sample(3, n, replace = TRUE, prob = c(0.6, 0.2, 0.2)) - 1.6
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
cov <- t(Z) %*% cov_gZ / n
n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 0.1
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- (2*rbinom(q, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 2
n <- 100000
q <- 50
s <- 5
nu <- 0.1
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(p)
gamma <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
n <- 100000
q <- 50
s <- 5
nu <- 0.1
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(q)
gamma <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 0.001
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(q)
gamma <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * g_Z
}
n <- 100000
q <- 50
s <- 5
nu <- 0.01
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
n <- 100000
q <- 50
s <- 5
nu <- 0.01
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * (2+g_Z)
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 0.1
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * (g_Z)
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 0.1
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(q)
gamma[1:s] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * (2+g_Z)
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 0.1
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(q)
gamma[1:q] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * (2+g_Z)
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 100000
q <- 50
s <- 5
nu <- 5
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- rnorm(n)
}
gamma <- numeric(q)
gamma[1:q] <- (2*rbinom(s, 1, 0.5) - 1)*nu
g_Z <- Z %*% gamma
cov_gZ <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
cov_gZ[, j] <- Z[, j] * (2+g_Z)
}
cov <- t(Z) %*% cov_gZ / n
solve(cov)
n <- 20000
q <- 100
nu <- 0.5
L <- 10
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- sample(3, n, replace = TRUE, prob = c(0.6, 0.2, 0.2)) - 1.6
}
gz <- Z %*% nu*(2*rbinom(q, 1, 0.5) - 1)
q
nu*(2*rbinom(q, 1, 0.5) - 1)
dim(Z)
gz <- Z %*% t(nu*(2*rbinom(q, 1, 0.5) - 1))
Z %*% nu*(2*rbinom(q, 1, 0.5) - 1)
gz <- Z %*% (nu*(2*rbinom(q, 1, 0.5) - 1))
g_Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
g_Z[, j] <- Z[, j] * (gz + L)
}
finalZ <- Z %*% g_Z / n
finalZ <- Z %*% t(g_Z) / n
n <- 5000
q <- 100
nu <- 0.5
L <- 10
Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
Z[, j] <- sample(3, n, replace = TRUE, prob = c(0.6, 0.2, 0.2)) - 1.6
}
gz <- Z %*% (nu*(2*rbinom(q, 1, 0.5) - 1))
g_Z <- matrix(0, nrow = n, ncol = q)
for (j in 1:q) {
g_Z[, j] <- Z[, j] * (gz + L)
}
finalZ <- Z %*% t(g_Z) / n
inv.finalZ <- solve(finalZ)
matrx(1, 2,2) * c(1,1)
matrix(1, 2,2) * c(1,1)
matrix(1, 2,2) * c(1,2)
c(1,2) * matrix(1, 2,2)
t(c(1,2)) * matrix(1, 2,2)
rnor
rnorm(30)
knitr::opts_chunk$set(echo = TRUE)
library(eva)
library(tidyverse)
library(katlabutils)
library(cowplot)
library(fitdistrplus)
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
# load empirical distributions
resampling_dists <- readRDS(paste0(sceptre2_results_dir, "resampling_distributions/sceptre_resampling_dists.rds"))
resampling_dists[1:5, 1:6]
round(seq(1e4, 1e3, length.out = 10), 0)
q_list <- c(0.96)
samples_list <- c(5e3, 3e3, 1e3)
fitting_fun <- gpdAd
for (i in 1:length(q_list)) {
for (j in 1:length(samples_list)) {
# extract percentile and no_samples
q <- q_list[i]
samples <- samples_list[j]
# require to be in the low_moi_explore folder
# make a directory given the number of percentile and the number of resamples
working_dir <- getwd()
subDir <- sprintf("figures/power_exploration/%d_resamples_%.2f_percentile",  samples, q)
dir.create(file.path(working_dir, subDir))
# create gpd parameter matrix
gpd_param <- list(left = matrix(0, nrow = 5, ncol = nrow(resampling_dists)),
right = matrix(0, nrow = 5, ncol = nrow(resampling_dists)))
for (l in 1:nrow(resampling_dists)){
if (l %in% c(163, 177, 198)){
next
}
# extract index of resampling distribution
idx <- l
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
for(tail in c("left", "right")){
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- sign_flip*z_null
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
out <- fitting_fun(z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
dgpd_density <- function(x) {
(1 - q) * dgpd(sign_flip*x,
loc = u_pos,
scale = out$theta["Scale"],
shape = out$theta["Shape"])
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(out$statistic/n), out$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
loc = u_pos,
scale = out$theta["Scale"],
shape = out$theta["Shape"])
expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
loc = u_pos,
scale = out$theta["Scale"],
shape = out$theta["Shape"])
tibble(expected_unif) %>%
ggplot(aes(y = expected_unif)) +
stat_qq_points() +
stat_qq_band() +
geom_abline()
hist(expected_unif)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
plots[[tail]] <- plot_grid(hist_full,
hist_tail,
qq_plot,
ncol = 1,
rel_heights = c(1,1,1.5),
align = "v")
# save the gpd parameters and gof statistics and p-value
gpd_param[[which(names(gpd_param) == tail)]][1, l] <- u_pos
gpd_param[[which(names(gpd_param) == tail)]][2, l] <- out$theta["Scale"]
gpd_param[[which(names(gpd_param) == tail)]][3, l] <- out$theta["Shape"]
gpd_param[[which(names(gpd_param) == tail)]][4, l] <- out$statistic
gpd_param[[which(names(gpd_param) == tail)]][5, l] <- out$p.value
}
# plot
final_plot <- plot_grid(plots[["left"]], plots[["right"]])
# save the plot in specific folder
save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
# save the gpd parameter matrix and goodness of fit statistic and p-value
write.csv(gpd_param, sprintf("%s/%d.csv", file.path(working_dir, subDir), idx))
print(l)
}
print(j)
}
print(i)
}
setwd("~/Documents/Projects/sceptre2/sceptre2-manuscript/writeups/resampling_distributions/low_moi_explore")
for (i in 1:length(q_list)) {
for (j in 1:length(samples_list)) {
# extract percentile and no_samples
q <- q_list[i]
samples <- samples_list[j]
# require to be in the low_moi_explore folder
# make a directory given the number of percentile and the number of resamples
working_dir <- getwd()
subDir <- sprintf("figures/power_exploration/%d_resamples_%.2f_percentile",  samples, q)
dir.create(file.path(working_dir, subDir))
# create gpd parameter matrix
gpd_param <- list(left = matrix(0, nrow = 5, ncol = nrow(resampling_dists)),
right = matrix(0, nrow = 5, ncol = nrow(resampling_dists)))
for (l in 1:nrow(resampling_dists)){
if (l %in% c(163, 177, 198)){
next
}
# extract index of resampling distribution
idx <- l
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
for(tail in c("left", "right")){
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- sign_flip*z_null
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
out <- fitting_fun(z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
dgpd_density <- function(x) {
(1 - q) * dgpd(sign_flip*x,
loc = u_pos,
scale = out$theta["Scale"],
shape = out$theta["Shape"])
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(out$statistic/n), out$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
loc = u_pos,
scale = out$theta["Scale"],
shape = out$theta["Shape"])
expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
loc = u_pos,
scale = out$theta["Scale"],
shape = out$theta["Shape"])
tibble(expected_unif) %>%
ggplot(aes(y = expected_unif)) +
stat_qq_points() +
stat_qq_band() +
geom_abline()
hist(expected_unif)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
plots[[tail]] <- plot_grid(hist_full,
hist_tail,
qq_plot,
ncol = 1,
rel_heights = c(1,1,1.5),
align = "v")
# save the gpd parameters and gof statistics and p-value
gpd_param[[which(names(gpd_param) == tail)]][1, l] <- u_pos
gpd_param[[which(names(gpd_param) == tail)]][2, l] <- out$theta["Scale"]
gpd_param[[which(names(gpd_param) == tail)]][3, l] <- out$theta["Shape"]
gpd_param[[which(names(gpd_param) == tail)]][4, l] <- out$statistic
gpd_param[[which(names(gpd_param) == tail)]][5, l] <- out$p.value
}
# plot
final_plot <- plot_grid(plots[["left"]], plots[["right"]])
# save the plot in specific folder
save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
# save the gpd parameter matrix and goodness of fit statistic and p-value
write.csv(gpd_param, sprintf("%s/%d.csv", file.path(working_dir, subDir), idx))
print(l)
}
print(j)
}
print(i)
}
