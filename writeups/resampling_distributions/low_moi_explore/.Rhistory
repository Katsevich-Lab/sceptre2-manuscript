z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
log(10)
install.packages("EnvStats")
# proposal 3: fit Pareto distribution
library(EnvStats)
help("dpareto")
tail <- "right"
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# explicity MLE for Pareto fit
x_mle <- min(trun_data)
alpha_mle <- n / (sum(log(trun_data / x_mle)))
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "ppareto", x_mle, alpha_mle)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
alpha_mle
test_ks
dpareto_density <- function(x) {
(1 - q) * dpareto(sign_flip*x,
location = x_mle,
shape = alpha_mle)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
hist_tail
idx <- 50
idx <- 50
q <- 0.9
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
sign_flip <- if(tail == "right") 1 else -1
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# explicity MLE for Pareto fit
x_mle <- min(trun_data)
alpha_mle <- n / (sum(log(trun_data / x_mle)))
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "ppareto", x_mle, alpha_mle)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
test_ks
alpha_mle
dpareto_density <- function(x) {
(1 - q) * dpareto(sign_flip*x,
location = x_mle,
shape = alpha_mle)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
hist_tail
idx <- 50
q <- 0.99
q <- 0.99
samples <- 5e5
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# explicity MLE for Pareto fit
x_mle <- min(trun_data)
alpha_mle <- n / (sum(log(trun_data / x_mle)))
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "ppareto", x_mle, alpha_mle)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
dpareto_density <- function(x) {
(1 - q) * dpareto(sign_flip*x,
location = x_mle,
shape = alpha_mle)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
hist_tai;
hist_tail
expected_quantiles_pos <- qpareto(p = (2*(1:n)-1)/(2*n),
location = x_mle,
shape = alpha_mle)
expected_unif <- ppareto(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
location = x_mle,
shape = alpha_mle)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
# plot the tail probability
observed_tail_prob <- (10:(0.1*n))/n
observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
gpd_tail_prob <- 1 - as.vector(pgpd(q = observed_extreme_quantile,
location = x_mle,
shape = alpha_mle))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
gpd_tail_prob = gpd_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
gpd_tail_prob <- 1 - as.vector(ppareto(q = observed_extreme_quantile,
location = x_mle,
shape = alpha_mle))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
gpd_tail_prob = gpd_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
p_plot
qq_plot
q <- 0.96
samples <- 5e5
working_dir <- getwd()
working_dir <- getwd()
subDir <- sprintf("figures/power_exploration/Pareto_%d_resamples_%.2f_percentile",  samples, q)
dir.create(file.path(working_dir, subDir))
# create gpd parameter matrix
pareto_param <- list(left = matrix(0, nrow = 5, ncol = nrow(resampling_dists)),
right = matrix(0, nrow = 5, ncol = nrow(resampling_dists)))
for (l in 1:nrow(resampling_dists)){
# extract index of resampling distribution
idx <- l
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
for(tail in c("left", "right")){
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# explicity MLE for Pareto fit
x_mle <- min(trun_data)
alpha_mle <- n / (sum(log(trun_data / x_mle)))
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "ppareto", x_mle, alpha_mle)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
# if(is.nan(test_ks$p.value)){
#   sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
#   # k-s test
#   test_ks <- ks.test(trun_data, sim_data)
# }
dpareto_density <- function(x) {
(1 - q) * dpareto(sign_flip*x,
location = x_mle,
shape = alpha_mle)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue") +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank())
expected_quantiles_pos <- qpareto(p = (2*(1:n)-1)/(2*n),
location = x_mle,
shape = alpha_mle)
expected_unif <- ppareto(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
location = x_mle,
shape = alpha_mle)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
# plot the tail probability
observed_tail_prob <- (10:(0.1*n))/n
observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
pareto_tail_prob <- 1 - as.vector(ppareto(q = observed_extreme_quantile,
location = x_mle,
shape = alpha_mle))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
pareto_tail_prob = pareto_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = pareto_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
# store the plot
plots[[tail]] <- plot_grid(qq_plot,
p_plot,
ncol = 1,
rel_heights = c(1.5, 1.5),
align = "v")
# compute the ratio p-value
ratio_pvalue <- max(pareto_tail_prob / observed_tail_prob,
observed_tail_prob / pareto_tail_prob)
print(ratio_pvalue)
# save the gpd parameters and gof statistics and p-value
pareto_param[[which(names(pareto_param) == tail)]][1, l] <- x_mle
pareto_param[[which(names(pareto_param) == tail)]][2, l] <- alpha_mle
pareto_param[[which(names(pareto_param) == tail)]][3, l] <- test_ks$statistic
pareto_param[[which(names(pareto_param) == tail)]][4, l] <- test_ks$p.value
pareto_param[[which(names(pareto_param) == tail)]][5, l] <- ratio_pvalue
}
# plot
final_plot <- plot_grid(plots[["left"]], plots[["right"]])
# save the plot in specific folder
save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
print(l)
}
# create gpd parameter matrix
pareto_param <- list(left = matrix(0, nrow = 5, ncol = nrow(resampling_dists)),
right = matrix(0, nrow = 5, ncol = nrow(resampling_dists)))
for (l in 1:nrow(resampling_dists)){
# extract index of resampling distribution
idx <- l
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
for(tail in c("left", "right")){
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# explicity MLE for Pareto fit
x_mle <- min(trun_data)
alpha_mle <- n / (sum(log(trun_data / x_mle)))
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "ppareto", x_mle, alpha_mle)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
# if(is.nan(test_ks$p.value)){
#   sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
#   # k-s test
#   test_ks <- ks.test(trun_data, sim_data)
# }
dpareto_density <- function(x) {
(1 - q) * dpareto(sign_flip*x,
location = x_mle,
shape = alpha_mle)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue")
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank()) +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
expected_quantiles_pos <- qpareto(p = (2*(1:n)-1)/(2*n),
location = x_mle,
shape = alpha_mle)
expected_unif <- ppareto(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
location = x_mle,
shape = alpha_mle)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
# plot the tail probability
observed_tail_prob <- (10:(0.1*n))/n
observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
pareto_tail_prob <- 1 - as.vector(ppareto(q = observed_extreme_quantile,
location = x_mle,
shape = alpha_mle))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
pareto_tail_prob = pareto_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = pareto_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
# store the plot
plots[[tail]] <- plot_grid(hist_tail,
qq_plot,
p_plot,
ncol = 1,
rel_heights = c(2, 1.5, 1.5),
align = "v")
# compute the ratio p-value
ratio_pvalue <- max(pareto_tail_prob / observed_tail_prob,
observed_tail_prob / pareto_tail_prob)
print(ratio_pvalue)
# save the gpd parameters and gof statistics and p-value
pareto_param[[which(names(pareto_param) == tail)]][1, l] <- x_mle
pareto_param[[which(names(pareto_param) == tail)]][2, l] <- alpha_mle
pareto_param[[which(names(pareto_param) == tail)]][3, l] <- test_ks$statistic
pareto_param[[which(names(pareto_param) == tail)]][4, l] <- test_ks$p.value
pareto_param[[which(names(pareto_param) == tail)]][5, l] <- ratio_pvalue
}
# plot
final_plot <- plot_grid(plots[["left"]], plots[["right"]])
# save the plot in specific folder
save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
print(l)
}
working_dir <- getwd()
subDir <- sprintf("figures/power_exploration/Pareto_%d_resamples_%.2f_percentile",  samples, q)
dir.create(file.path(working_dir, subDir))
# create gpd parameter matrix
pareto_param <- list(left = matrix(0, nrow = 5, ncol = nrow(resampling_dists)),
right = matrix(0, nrow = 5, ncol = nrow(resampling_dists)))
for (l in 1:nrow(resampling_dists)){
# extract index of resampling distribution
idx <- l
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
for(tail in c("left", "right")){
sign_flip <- if(tail == "right") 1 else -1
z_null_pos <- (sign_flip*z_null)
u_pos <- quantile(z_null_pos, q)
u <- sign_flip*u_pos
# extract the data
trun_data <- (z_null_pos[z_null_pos > u_pos])
n <- sum(z_null_pos > u_pos)
# explicity MLE for Pareto fit
x_mle <- min(trun_data)
alpha_mle <- n / (sum(log(trun_data / x_mle)))
# first fit ks.test with estimated parameter; if there is Na, switch to simulation
test_ks <- ks.test(trun_data, "ppareto", x_mle, alpha_mle)
print(is.nan(test_ks$p.value))
print(test_ks$p.value)
# if(is.nan(test_ks$p.value)){
#   sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
#   # k-s test
#   test_ks <- ks.test(trun_data, sim_data)
# }
dpareto_density <- function(x) {
(1 - q) * dpareto(sign_flip*x,
location = x_mle,
shape = alpha_mle)
}
if(tail == "right"){
x_min <- u
x_max <- max(z_null)
} else{
x_min <- min(z_null)
x_max <- u
}
hist_full <- tibble(z_null) %>%
ggplot(aes(x = z_null)) +
geom_histogram(aes(y = ..density..), bins = 1000) +
geom_vline(xintercept = u, linetype = "dashed", color = "red") +
stat_function(fun = dgpd_density,
xlim = c(x_min, x_max),
color = "dodgerblue")
hist_tail <- hist_full +
coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
theme(plot.title = element_blank()) +
labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
theme(plot.title = element_text(hjust = 0.5))
expected_quantiles_pos <- qpareto(p = (2*(1:n)-1)/(2*n),
location = x_mle,
shape = alpha_mle)
expected_unif <- ppareto(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
location = x_mle,
shape = alpha_mle)
qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
ggplot(aes(x = expected_quantile, y = observed_quantile)) +
geom_line() +
geom_abline(linetype = "dashed", color = "red")
# plot the tail probability
observed_tail_prob <- (10:(0.1*n))/n
observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
pareto_tail_prob <- 1 - as.vector(ppareto(q = observed_extreme_quantile,
location = x_mle,
shape = alpha_mle))
# plot the tail probability
p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
pareto_tail_prob = pareto_tail_prob,
observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
ggplot(aes(x = pareto_tail_prob, y = observed_tail_prob)) +
geom_line() +
geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
linetype = "dashed", colour="blue")+
geom_abline(linetype = "dashed", color = "red") +
scale_x_continuous(trans = c("log10", "reverse")) +
scale_y_continuous(trans = c("log10", "reverse"))
# store the plot
plots[[tail]] <- plot_grid(hist_tail,
qq_plot,
p_plot,
ncol = 1,
rel_heights = c(2, 1.5, 1.5),
align = "v")
# compute the ratio p-value
ratio_pvalue <- max(pareto_tail_prob / observed_tail_prob,
observed_tail_prob / pareto_tail_prob)
print(ratio_pvalue)
# save the gpd parameters and gof statistics and p-value
pareto_param[[which(names(pareto_param) == tail)]][1, l] <- x_mle
pareto_param[[which(names(pareto_param) == tail)]][2, l] <- alpha_mle
pareto_param[[which(names(pareto_param) == tail)]][3, l] <- test_ks$statistic
pareto_param[[which(names(pareto_param) == tail)]][4, l] <- test_ks$p.value
pareto_param[[which(names(pareto_param) == tail)]][5, l] <- ratio_pvalue
}
# plot
final_plot <- plot_grid(plots[["left"]], plots[["right"]])
# save the plot in specific folder
save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
print(l)
}
l
tail
