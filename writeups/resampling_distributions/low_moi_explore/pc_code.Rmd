---
title: "GPD Goodness of Fit for SCEPTRE PC Instances"
author: "Ziang"
date: "2023-02-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Intro

```{r, warning = FALSE, error = FALSE, message = FALSE}
library(eva)
library(tidyverse)
library(katlabutils)
library(cowplot)
library(scales)

sceptre2_pc_dir <- "~/Documents/Projects/aux-sceptre2"
# load empirical distributions
resampling_dists <- readRDS(paste0(sceptre2_pc_dir, "/sceptre_resampling_dists_pc.rds"))
resampling_dists[1:5, 1:6]
```


```{r}

q_list <- c(0.96)
samples_list <- 5e5


for (i in 1:length(q_list)) {
  for (j in 1:1) {
    # extract percentile and no_samples
    q <- q_list[i]
    samples <- samples_list[j]
    # require to be in the low_moi_explore folder
    # make a directory given the number of percentile and the number of resamples
    working_dir <- getwd()
    subDir <- sprintf("figures/tail_prob_%d_resamples_%.2f_percentile",  samples, q)
    dir.create(file.path(working_dir, subDir))
    
    # create gpd parameter matrix
    gpd_param <- list(left = matrix(0, nrow = 6, ncol = nrow(resampling_dists)),
                      right = matrix(0, nrow = 6, ncol = nrow(resampling_dists)))
    
    for (l in 1:nrow(resampling_dists)){
      # extract index of resampling distribution
      idx <- l
      z_null <- as.numeric(resampling_dists[idx,2:(1+samples)])
      obs_stat <- as.numeric(resampling_dists[idx,1])
      plots <- list()
      
      for(tail in c("left", "right")){
        sign_flip <- if(tail == "right") 1 else -1
        z_null_pos <- sign_flip*z_null
        u_pos <- quantile(z_null_pos, q)
        u <- sign_flip*u_pos
        
        # extract the data
        trun_data <- z_null_pos[z_null_pos > u_pos]
        n <- sum(z_null_pos > u_pos)
        
        # method of moment
        xi_mom <- (1 - (mean(trun_data) - u_pos)^2/var(trun_data))/2
        sig_mom <- (mean(trun_data) - u_pos)*(1 - xi_mom)
        
        # first fit ks.test with estimated parameter; if there is Na, switch to simulation
        test_ks <- ks.test(trun_data, "pgpd", u_pos, sig_mom, xi_mom)
        print(is.nan(test_ks$p.value))
        print(test_ks$p.value)
        if(is.nan(test_ks$p.value)){
          sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
          # k-s test
          test_ks <- ks.test(trun_data, sim_data)
        }
        
        
        dgpd_density <- function(x) {
          (1 - q) * dgpd(sign_flip*x,
                         loc = u_pos,
                         scale = sig_mom,
                         shape = xi_mom)
        }
        
        if(tail == "right"){
          lb_data <- u
          ub_data <- max(z_null)
          x_min <- u
          x_max <- max(sign_flip*(u_pos - sig_mom/xi_mom), obs_stat)
        } else{
          lb_data <- min(z_null)
          ub_data <- u
          x_min <- min(sign_flip*(u_pos - sig_mom/xi_mom), obs_stat)
          x_max <- u
        }
        
        
        
        if(xi_mom < 0){
          hist_full <- tibble(z_null) %>%
            ggplot(aes(x = z_null)) +
            geom_histogram(aes(y = ..density..), bins = 1000) +
            geom_vline(xintercept = u, linetype = "dashed", color = "red") +
            geom_vline(xintercept = sign_flip*(u_pos - sig_mom/xi_mom), linetype = "dashed", color = "lightblue") +
            # add observed test statistic
            geom_vline(xintercept = obs_stat, linetype = "dashed", color = "purple") +
            stat_function(fun = dgpd_density,
                          xlim = c(lb_data, ub_data),
                          color = "dodgerblue")
        }else{
          hist_full <- tibble(z_null) %>%
            ggplot(aes(x = z_null)) +
            geom_histogram(aes(y = ..density..), bins = 1000) +
            geom_vline(xintercept = u, linetype = "dashed", color = "red") +
            # add observed test statistic
            geom_vline(xintercept = obs_stat, linetype = "dashed", color = "purple") +
            stat_function(fun = dgpd_density,
                          xlim = c(lb_data, ub_data),
                          color = "dodgerblue")
        }
        
          hist_tail <- hist_full +
            coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
            theme(plot.title = element_blank()) +
            labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
            theme(plot.title = element_text(hjust = 0.5))
        
        expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
                                       loc = u_pos,
                                       scale = sig_mom,
                                       shape = xi_mom)
        expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
                              loc = u_pos,
                              scale = sig_mom,
                              shape = xi_mom)
        
        qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
                          observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
          ggplot(aes(x = expected_quantile, y = observed_quantile)) +
          geom_line() +
          geom_abline(linetype = "dashed", color = "red")
        
        # plot the tail probability
        observed_tail_prob <- (10:(0.1*n))/n
        observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
        gpd_tail_prob <- 1 - as.vector(pgpd(q = observed_extreme_quantile,
                                            loc = u_pos,
                                            scale = sig_mom,
                                            shape = xi_mom))
        # plot the tail probability
        p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
                         gpd_tail_prob = gpd_tail_prob,
                         observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
                         observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
          ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
          geom_line() +
          geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
                      linetype = "dashed", colour="blue")+
          geom_abline(linetype = "dashed", color = "red") +
          scale_x_continuous(trans = c("log10", "reverse")) +
          scale_y_continuous(trans = c("log10", "reverse"))
        
        # store the plot
        plots[[tail]] <- plot_grid(hist_tail,
                                   hist_full,
                                   p_plot,
                                   ncol = 1,
                                   rel_heights = c(2, 2, 2),
                                   align = "v")
        
        # compute the ratio p-value
        ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
                            observed_tail_prob / gpd_tail_prob, na.rm = TRUE)
        print(ratio_pvalue)
        print(xi_mom)
        # save the gpd parameters and gof statistics and p-value
        gpd_param[[which(names(gpd_param) == tail)]][1, l] <- u_pos
        gpd_param[[which(names(gpd_param) == tail)]][2, l] <- sig_mom
        gpd_param[[which(names(gpd_param) == tail)]][3, l] <- xi_mom
        gpd_param[[which(names(gpd_param) == tail)]][4, l] <- test_ks$statistic
        gpd_param[[which(names(gpd_param) == tail)]][5, l] <- test_ks$p.value
        gpd_param[[which(names(gpd_param) == tail)]][6, l] <- ratio_pvalue
      }
      
      # plot
      final_plot <- plot_grid(plots[["left"]], plots[["right"]])
      
      # save the plot in specific folder
      save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
      print(l)
    }
    # save the gpd parameter matrix and goodness of fit statistic and p-value
    write.csv(gpd_param, sprintf("%s/param.csv", file.path(working_dir, subDir)))
  }
}

# plot shape against scale
param <- read.csv(sprintf("%s/param.csv", file.path(working_dir, subDir)))
param <- t(matrix(as.numeric(unlist(param[,-1])), nrow = 6, ncol = 660))
param <- as.data.frame(param)
colnames(param) <- c("location", "scale", "shape", "statistic", "p-value", "p-value ratio")
a <- tibble(param) %>%
          ggplot(aes(x = scale, y = shape)) +
  geom_point()
save_plot(sprintf("%s/scale-shape.pdf", file.path(working_dir, subDir)), a)

# plot shape against effective sample size
eff_ss <- resampling_dists[,3]
param$eff_ss <- as.factor(rep(eff_ss, 2))

## Left tail (vary with effective sample size)
left_shape_boxplot <- ggplot(param[1:330,], aes(x = eff_ss, y = shape)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("left tail") +
  labs(title="Shape versus effective sample size")+
  theme()
left_scale_boxplot <- ggplot(param[1:330,], aes(x = eff_ss, y = scale)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("left tail") +
  labs(title="Scale versus effective sample size")+
  theme()
## Right tail (does not vary much with effective sample size)
right_shape_boxplot <- ggplot(param[331:660,], aes(x = eff_ss, y = shape)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("right tail")
right_scale_boxplot <- ggplot(param[331:660,], aes(x = eff_ss, y = scale)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("right tail")

shape_plot <- plot_grid(left_shape_boxplot, 
          right_shape_boxplot,
          ncol = 1,
          rel_heights = c(2,2),
          align = "v")

scale_plot <- plot_grid(left_scale_boxplot, 
          right_scale_boxplot,
          ncol = 1,
          rel_heights = c(2,2),
          align = "v")
# save plot
save_plot(sprintf("%s/shape-effss.pdf", file.path(working_dir, subDir)), shape_plot)
save_plot(sprintf("%s/scale-effss.pdf", file.path(working_dir, subDir)), scale_plot)

```

# fit normal distribution

```{r}

q_list <- c(0.96)
samples_list <- 5e5
library(actuar)
library(pracma)
library(truncnorm)

for (i in 1:length(q_list)) {
  for (j in 1:1) {
    # extract percentile and no_samples
    q <- q_list[i]
    samples <- samples_list[j]
    # require to be in the low_moi_explore folder
    # make a directory given the number of percentile and the number of resamples
    working_dir <- "/Users/ziang/Dropbox/Mac/Documents/Projects/aux-sceptre2"
    subDir <- sprintf("figures/norm_tail_%d_resamples_%.2f_percentile",  samples, q)
    dir.create(file.path(working_dir, subDir))
    
    # create gpd parameter matrix
    gpd_param <- list(left = matrix(0, nrow = 6, ncol = nrow(resampling_dists)),
                      right = matrix(0, nrow = 6, ncol = nrow(resampling_dists)))
    
    for (l in 1:nrow(resampling_dists)){
      # extract index of resampling distribution
      idx <- l
      z_null <- as.numeric(resampling_dists[idx,2:(1+samples)])
      obs_stat <- as.numeric(resampling_dists[idx,1])
      plots <- list()
      
      for(tail in c("left", "right")){
        sign_flip <- if(tail == "right") 1 else -1
        z_null_pos <- sign_flip*z_null
        u_pos <- quantile(z_null_pos, q)
        u <- sign_flip*u_pos
        
        # extract the data
        trun_data <- z_null_pos[z_null_pos > u_pos]
        n <- sum(z_null_pos > u_pos)
        
        # method of moment
        mu <- mean(z_null)
        sigma <- sd(z_null)
        # first fit ks.test with estimated parameter; if there is Na, switch to simulation
        test_ks <- ks.test(trun_data, "pnorm", mean = mu, sd = sigma)
        print(is.nan(test_ks$p.value))
        print(test_ks$p.value)
        if(is.nan(test_ks$p.value)){
          sim_data <- rtruncnorm(1e6, a = u_pos, mean = mu, sd = sigma)
          # k-s test
          test_ks <- ks.test(trun_data, sim_data)
        }
        
        
        if(tail == "right"){
          lb_data <- u
          ub_data <- max(z_null)
          x_min <- u
          x_max <- max(z_null)
        } else{
          lb_data <- min(z_null)
          ub_data <- u
          x_min <- min(z_null)
          x_max <- u
        }
        
        norm_density <- function(x){
          dnorm(x, mean = mu, sd = sigma)
        }

          hist_full <- tibble(z_null) %>%
            ggplot(aes(x = z_null)) +
            geom_histogram(aes(y = ..density..), bins = 1000) +
            geom_vline(xintercept = u, linetype = "dashed", color = "red") +
            # add observed test statistic
            geom_vline(xintercept = obs_stat, linetype = "dashed", color = "purple") +
            stat_function(fun = norm_density,
                          xlim = c(lb_data, ub_data),
                          color = "dodgerblue")
        
          hist_tail <- hist_full +
            coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, norm_density(as.numeric(u))*1.5)) +
            theme(plot.title = element_blank()) +
            labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
            theme(plot.title = element_text(hjust = 0.5))
        
        expected_quantiles_pos <- qnorm(p = (2*(1:n)-1)/(2*n),
                                             mean = mu,
                                             sd = sigma)
        expected_unif <- pnorm(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
                                    mean = mu,
                                    sd = sigma)
        
        qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
                          observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
          ggplot(aes(x = expected_quantile, y = observed_quantile)) +
          geom_line() +
          geom_abline(linetype = "dashed", color = "red")
        
        # plot the tail probability
        observed_tail_prob <- (10:(0.1*n))/n
        observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
        gpd_tail_prob <- 1 - as.vector(pnorm(q = observed_extreme_quantile,
                                             mean = mu,
                                             sd = sigma))
        # plot the tail probability
        p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
                         gpd_tail_prob = gpd_tail_prob,
                         observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
                         observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
          ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
          geom_line() +
          geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
                      linetype = "dashed", colour="blue")+
          geom_abline(linetype = "dashed", color = "red") +
          scale_x_continuous(trans = c("log10", "reverse")) +
          scale_y_continuous(trans = c("log10", "reverse"))
        
        # store the plot
        plots[[tail]] <- plot_grid(hist_tail,
                                   hist_full,
                                   p_plot,
                                   ncol = 1,
                                   rel_heights = c(2, 2, 2),
                                   align = "v")
        
        # compute the ratio p-value
        ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
                            observed_tail_prob / gpd_tail_prob, na.rm = TRUE)
        print(ratio_pvalue)
        # save the gpd parameters and gof statistics and p-value
        gpd_param[[which(names(gpd_param) == tail)]][1, l] <- u_pos
        gpd_param[[which(names(gpd_param) == tail)]][2, l] <- mu
        gpd_param[[which(names(gpd_param) == tail)]][3, l] <- sigma
        gpd_param[[which(names(gpd_param) == tail)]][4, l] <- test_ks$statistic
        gpd_param[[which(names(gpd_param) == tail)]][5, l] <- test_ks$p.value
        gpd_param[[which(names(gpd_param) == tail)]][6, l] <- ratio_pvalue
      }
      
      # plot
      final_plot <- plot_grid(plots[["left"]], plots[["right"]])
      
      # save the plot in specific folder
      save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
      print(l)
    }
    # save the gpd parameter matrix and goodness of fit statistic and p-value
    write.csv(gpd_param, sprintf("%s/param.csv", file.path(working_dir, subDir)))
  }
}

# plot shape against scale
param <- read.csv(sprintf("%s/param.csv", file.path(working_dir, subDir)))
param <- t(matrix(as.numeric(unlist(param[,-1])), nrow = 6, ncol = 660))
param <- as.data.frame(param)
colnames(param) <- c("location", "scale", "shape", "statistic", "p-value", "p-value ratio")
a <- tibble(param) %>%
          ggplot(aes(x = scale, y = shape)) +
  geom_point()
save_plot(sprintf("%s/scale-shape.pdf", file.path(working_dir, subDir)), a)

# plot shape against effective sample size
eff_ss <- resampling_dists[,3]
param$eff_ss <- as.factor(rep(eff_ss, 2))

## Left tail (vary with effective sample size)
left_shape_boxplot <- ggplot(param[1:330,], aes(x = eff_ss, y = shape)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("left tail") +
  labs(title="Shape versus effective sample size")+
  theme()
left_scale_boxplot <- ggplot(param[1:330,], aes(x = eff_ss, y = scale)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("left tail") +
  labs(title="Scale versus effective sample size")+
  theme()
## Right tail (does not vary much with effective sample size)
right_shape_boxplot <- ggplot(param[331:660,], aes(x = eff_ss, y = shape)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("right tail")
right_scale_boxplot <- ggplot(param[331:660,], aes(x = eff_ss, y = scale)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("right tail")

shape_plot <- plot_grid(left_shape_boxplot, 
          right_shape_boxplot,
          ncol = 1,
          rel_heights = c(2,2),
          align = "v")

scale_plot <- plot_grid(left_scale_boxplot, 
          right_scale_boxplot,
          ncol = 1,
          rel_heights = c(2,2),
          align = "v")
# save plot
save_plot(sprintf("%s/shape-effss.pdf", file.path(working_dir, subDir)), shape_plot)
save_plot(sprintf("%s/scale-effss.pdf", file.path(working_dir, subDir)), scale_plot)

```
# fit skew normal distribution

```{r}

q_list <- c(0.96)
samples_list <- 5e5
library(actuar)
library(pracma)
library(truncnorm)
library(sn)

for (i in 1:length(q_list)) {
  for (j in 1:1) {
    # extract percentile and no_samples
    q <- q_list[i]
    samples <- samples_list[j]
    # require to be in the low_moi_explore folder
    # make a directory given the number of percentile and the number of resamples
    working_dir <- "/Users/ziang/Dropbox/Mac/Documents/Projects/aux-sceptre2"
    subDir <- sprintf("figures/sknorm_tail_%d_resamples_%.2f_percentile",  samples, q)
    dir.create(file.path(working_dir, subDir))
    
    # create gpd parameter matrix
    gpd_param <- list(left = matrix(0, nrow = 6, ncol = nrow(resampling_dists)),
                      right = matrix(0, nrow = 6, ncol = nrow(resampling_dists)))
    
    for (l in 1:nrow(resampling_dists)){
      # extract index of resampling distribution
      idx <- l
      z_null <- as.numeric(resampling_dists[idx,2:(1+samples)])
      obs_stat <- as.numeric(resampling_dists[idx,1])
      plots <- list()
      
      for(tail in c("left", "right")){
        sign_flip <- if(tail == "right") 1 else -1
        z_null_pos <- sign_flip*z_null
        u_pos <- quantile(z_null_pos, q)
        u <- sign_flip*u_pos
        
        # extract the data
        trun_data <- z_null_pos[z_null_pos > u_pos]
        n <- sum(z_null_pos > u_pos)
        
        # fit skew normal distribution
        out <- sn::selm(z_null ~ 1, family = "SN")
        # first fit ks.test with estimated parameter; if there is Na, switch to simulation
        test_ks <- ks.test(z_null, "psn", dp = out@param$dp)
        print(is.nan(test_ks$p.value))
        print(test_ks$p.value)
        if(is.nan(test_ks$p.value)){
          sim_data <- rtruncnorm(1e6, a = u_pos, mean = mu, sd = sigma)
          # k-s test
          test_ks <- ks.test(trun_data, sim_data)
        }
        
        
        sn_density <- function(x){
          dsn(x, dp = out@param$dp)
        }
        
        if(tail == "right"){
          lb_data <- u
          ub_data <- max(z_null)
          x_min <- u
          x_max <- max(z_null)
        } else{
          lb_data <- min(z_null)
          ub_data <- u
          x_min <- min(z_null)
          x_max <- u
        }
        
        norm_density <- function(x){
          dnorm(x, mean = mu, sd = sigma)
        }
        
        
        hist_full <- tibble(z_null) %>%
            ggplot(aes(x = z_null)) +
            geom_histogram(aes(y = ..density..), bins = 1000) +
            geom_vline(xintercept = u, linetype = "dashed", color = "red") +
            # add observed test statistic
            geom_vline(xintercept = obs_stat, linetype = "dashed", color = "purple") +
            stat_function(fun = sn_density,
                          xlim = c(lb_data, ub_data),
                          color = "dodgerblue")
        
          hist_tail <- hist_full +
            coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, norm_density(as.numeric(u))*1.5)) +
            theme(plot.title = element_blank()) +
            labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
            theme(plot.title = element_text(hjust = 0.5))
        
        expected_quantiles_pos <- qsn(p = (2*(1:n)-1)/(2*n),
                                           dp = out@param$dp)
        expected_unif <- psn(x = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
                                      dp = out@param$dp)
        
        qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
                          observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
          ggplot(aes(x = expected_quantile, y = observed_quantile)) +
          geom_line() +
          geom_abline(linetype = "dashed", color = "red")
        
        # plot the tail probability
        observed_tail_prob <- (10:(0.1*n))/n
        observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
        gpd_tail_prob <- 1 - as.vector(psn(x = observed_extreme_quantile,
                                           dp = out@param$dp))
        # plot the tail probability
        p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
                         gpd_tail_prob = gpd_tail_prob,
                         observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
                         observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
          ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
          geom_line() +
          geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
                      linetype = "dashed", colour="blue")+
          geom_abline(linetype = "dashed", color = "red") +
          scale_x_continuous(trans = c("log10", "reverse")) +
          scale_y_continuous(trans = c("log10", "reverse"))
        
        # store the plot
        plots[[tail]] <- plot_grid(hist_tail,
                                   hist_full,
                                   p_plot,
                                   ncol = 1,
                                   rel_heights = c(2, 2, 2),
                                   align = "v")
        
        # compute the ratio p-value
        ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
                            observed_tail_prob / gpd_tail_prob, na.rm = TRUE)
        print(ratio_pvalue)
        # save the gpd parameters and gof statistics and p-value
        gpd_param[[which(names(gpd_param) == tail)]][1, l] <- u_pos
        gpd_param[[which(names(gpd_param) == tail)]][2, l] <- mu
        gpd_param[[which(names(gpd_param) == tail)]][3, l] <- sigma
        gpd_param[[which(names(gpd_param) == tail)]][4, l] <- test_ks$statistic
        gpd_param[[which(names(gpd_param) == tail)]][5, l] <- test_ks$p.value
        gpd_param[[which(names(gpd_param) == tail)]][6, l] <- ratio_pvalue
      }
      
      # plot
      final_plot <- plot_grid(plots[["left"]], plots[["right"]])
      
      # save the plot in specific folder
      save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
      print(l)
    }
    # save the gpd parameter matrix and goodness of fit statistic and p-value
    write.csv(gpd_param, sprintf("%s/param.csv", file.path(working_dir, subDir)))
  }
}

# plot shape against scale
param <- read.csv(sprintf("%s/param.csv", file.path(working_dir, subDir)))
param <- t(matrix(as.numeric(unlist(param[,-1])), nrow = 6, ncol = 660))
param <- as.data.frame(param)
colnames(param) <- c("location", "scale", "shape", "statistic", "p-value", "p-value ratio")
a <- tibble(param) %>%
          ggplot(aes(x = scale, y = shape)) +
  geom_point()
save_plot(sprintf("%s/scale-shape.pdf", file.path(working_dir, subDir)), a)

# plot shape against effective sample size
eff_ss <- resampling_dists[,3]
param$eff_ss <- as.factor(rep(eff_ss, 2))

## Left tail (vary with effective sample size)
left_shape_boxplot <- ggplot(param[1:330,], aes(x = eff_ss, y = shape)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("left tail") +
  labs(title="Shape versus effective sample size")+
  theme()
left_scale_boxplot <- ggplot(param[1:330,], aes(x = eff_ss, y = scale)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("left tail") +
  labs(title="Scale versus effective sample size")+
  theme()
## Right tail (does not vary much with effective sample size)
right_shape_boxplot <- ggplot(param[331:660,], aes(x = eff_ss, y = shape)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("right tail")
right_scale_boxplot <- ggplot(param[331:660,], aes(x = eff_ss, y = scale)) + 
  stat_boxplot(geom = "errorbar", # Error bars
               width = 0.25) +    # Bars width
  geom_boxplot()+
  xlab("right tail")

shape_plot <- plot_grid(left_shape_boxplot, 
          right_shape_boxplot,
          ncol = 1,
          rel_heights = c(2,2),
          align = "v")

scale_plot <- plot_grid(left_scale_boxplot, 
          right_scale_boxplot,
          ncol = 1,
          rel_heights = c(2,2),
          align = "v")
# save plot
save_plot(sprintf("%s/shape-effss.pdf", file.path(working_dir, subDir)), shape_plot)
save_plot(sprintf("%s/scale-effss.pdf", file.path(working_dir, subDir)), scale_plot)

```

