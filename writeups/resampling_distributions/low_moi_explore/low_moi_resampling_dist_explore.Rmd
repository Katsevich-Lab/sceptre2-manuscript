---
title: "Initial exploration of SCEPTRE (full score statistic) resampling distributions"
author: "Tim"
date: "2022-12-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Intro

I briefly explore the empirical permutation distribution of the full score statistic that we use within SCEPTRE. The data frame of resampling distributions is as follows.

```{r, warning = FALSE, error = FALSE, message = FALSE}
library(evmix)
library(tidyverse)
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
# load empirical distributions
resampling_dists <- readRDS(paste0(sceptre2_results_dir, "resampling_distributions/sceptre_resampling_dists.rds"))
resampling_dists[1:5, 1:6]
```

There are 330 rows, each of which corresponds to a different gene-gRNA pair. The dataset and "effective sample size" (or `eff_ss'), defined as the number of treatment cells with nonzero expression, also are included as columns. The "Effective sample size" varies from 7 (our QC threshold) to 30.

```{r}
resampling_dists |>
  select(eff_ss, dataset) |>
  group_by(dataset, eff_ss) |>
  summarize(count = n()) |>
  print(n = 33)
```

Below, I write functions `analyze_pair` and `make_plot` that facilitate analyzing rows of the resampling distribution data frame. The funtion `analyze_pair` takes as input two arguments: (i) the row of the resampling distribution data frame to analyze, and (ii) the resampling distribution data frame itself. The function `make_plot` takes as input the output of `analyze_pair` and prints some helpful information about that pair.

```{r, warning = FALSE, error = FALSE, message = FALSE}
compute_one_sided_p_value <- function(z_null, z_star, right_tail = TRUE, cutoff = 0.99) {
  # investigate left tail or right tail
  z_null <- (if (right_tail) 1 else -1) * z_null
  u <- quantile(z_null, cutoff)[[1]]
  z_null_tail <- z_null[z_null > u]
  
  # fit GDP via MLE
  fit <- fgpd(x = z_null, u = u) # does the p-value estimate remain stable if we downsample z_null?
  
  # get the density of the fitted distribution
  x_grid <- seq(u, max(z_null_tail), length.out = 1000)
  y_dens <- dgpd(x = x_grid, u = u, sigmau = fit$mle[1], xi = fit$mle[2])
  fit_df <- data.frame(x = x_grid, y = y_dens)
  
  p <- data.frame(z = z_null_tail) |>
    ggplot(mapping = aes(x = z, y = after_stat(density))) +
    geom_histogram(bins = 30, fill = "grey", col = "black") +
    theme_bw() +
    geom_line(data = fit_df, mapping = aes(x = x, y = y), col = "blue") +
    geom_vline(xintercept = z_star, col = "red") +
    ggtitle(if(right_tail) "Right tail" else "Left tail")

  # compute the one-sided p-value
  emp_p <- mean(z_null > u) *  (1 - sceptre2:::compute_empirical_p_value(z_star, z_null_tail, side = "left"))
  p_p <- mean(z_null > u) * (1 - pgpd(q = z_star, u = u, sigmau = fit$mle[1], xi = fit$mle[2]))
  return(list(p = p, emp_p = emp_p, p_p = p_p))
}


analyze_pair <- function(i, resampling_dists) {
  info <- resampling_dists[i, 1:4]
  z_null <- (resampling_dists[i, 5:ncol(resampling_dists)] |> as.numeric())
  z_star <- quantile(abs(z_null), 0.99998)[[1]]
  
  p <- data.frame(z = z_null) |>
    ggplot(mapping = aes(x = z, y = after_stat(density))) +
    geom_histogram(bins = 30, fill = "grey", col = "black") +
    theme_bw() +
    geom_vline(xintercept = z_star, col = "red") +
    geom_vline(xintercept = -z_star, col = "red") +
    ggtitle("Whole distribution")
  
  left_tail <- compute_one_sided_p_value(z_null = z_null,
                                         z_star = z_star,
                                         right_tail = FALSE,
                                         cutoff = 0.99)
  
  right_tail <- compute_one_sided_p_value(z_null = z_null,
                                          z_star = z_star,
                                          right_tail = TRUE,
                                          cutoff = 0.99)
  
  return(list(left_tail = left_tail, right_tail = right_tail,
              whole_dist = p, info = info))
}

make_plot <- function(res) {
  plot(cowplot::plot_grid(res$whole_dist, res$left_tail$p, res$right_tail$p, ncol = 3))
  m <- matrix(c(res$left_tail$emp_p,
           res$left_tail$p_p,
           res$right_tail$emp_p,
           res$right_tail$p_p), nrow = 2)
  colnames(m) <- c("P(z_null < -|z|)", "P(z_null > |z|)")
  rownames(m) <- c("Empirical", "Parametric")
  print(m)
  cat("\n")
  print(res$info)
}
```

For example, below I call `analyze_pair` --- followed by `make_plot` --- on the third row of the resampling distribution data frame.

```{r, fig.height=3, fig.width=8}
analyze_pair(3, resampling_dists) |> make_plot()
```

I describe the outputs here. First, we have a plot of the empirical permutation distribution alongside the tails of this distribution. The leftmost plot shows the whole permutation distribution; the middle plot shows the left tail of the distribution, and the rightmost plot shows the right tail of the distribution. (I multiplied the test statistics $z_1, ..., z_{500,000}$ by negative 1 to create the left-tail plot.) I also plot the generalized Pareto distribution (GPD) fitted to both left and right tails of the distribution, which is superimposed on top of the histograms. Finally, the vertical red line represents a large value that we might obtain for the observed test statistic, $z_{obs}$. (Both $|z_{obs}|$ and $-|z_{obs}|$ are plotted). In particular, $z_{obs}$ is selected so that the empirical right-tailed p-value computed using $|z_{obs}|$ (or, equivalently, the left-tailed p-value computed using $-|z_{obs}|$) is equal to about 2e-5; our p-values need to be accurate out to about this level.

Next, the 2-by-2 table shows one-sided p-values. The columns correspond to $\mathbb{P}(z_{null} < -|z_{obs}|)$ and $\mathbb{P}(z_{null} > |z_{obs}|)$, respectively, and the rows correspond to whether the above probabilities are computed using the empirical distribution (top) or the parametric generalized Pareto distribution (bottom).

Finally, I print some information about this pair: the response ID, the gRNA group, the effective sample size, and the dataset from which the pair came.

# Some examples

I use the functions `analyze_pair` and `make_plot` to investigate several pairs. First, I plot a pair whose effective sample size is 7.

```{r, fig.height=3, fig.width=8}
analyze_pair(26, resampling_dists) |> make_plot()
```

The whole distribution clearly is asymmetric. The left tail is short and bumpy, providing a poor fit to the GPD. The right tail, meanwhile, is long and well-behaved, providing a very good fit to the GPD.

Now, I plot a pair whose effective sample size is 8.

```{r, fig.height=3, fig.width=8}
analyze_pair(57, resampling_dists) |> make_plot()
```

The story is similar to above: the left tail is short and bumpy, providing a poor fit to the GPD, while the right tail is long and nice, providing a good fit.

Next, I investigate a pair whose effective sample size is 12.

```{r, fig.height=3, fig.width=8}
analyze_pair(72, resampling_dists) |> make_plot()
```

The distribution is symmetric and both tails provide a good fit to the GPD.

The story is similar for pairs with an effective sample size of 15 and 30:

```{r, fig.height=3, fig.width=8}
analyze_pair(193, resampling_dists) |> make_plot()
```

```{r, fig.height=3, fig.width=8}
analyze_pair(193, resampling_dists) |> make_plot()
```

```{r, fig.height=3, fig.width=8}
analyze_pair(62, resampling_dists) |> make_plot()
```

Unfortunately, some pairs, especially those in the Papalexi dataset, have fairly wonky tails. For example:

```{r, fig.height=3, fig.width=8}
analyze_pair(163, resampling_dists) |> make_plot()
```

Modeling null distributions like these likely will be quite challenging. We might have to settle for returning an empirical p-value when the fit is this bad (as determined by, say, the KS statistic).

# Summary

The GPD seems to provide a reasonable fit to the tails of the resampling distribution, especially when the effective sample size is large. When the effective sample size is small (i.e., in the range of about 7 to 12), one tail of the distribution (typically the right tail) is well-behaved and provides a good fit to the GPD, while to other tail (typically the left tail) is bumpy and provides a poor fit to the GPD. Interestingly, the well-behaved tail seems to be the longer tail. Perhaps we can leverage this asymmetry to compute accurate two-tailed p-values for pairs with small effective sample sizes. Some pairs have very wonky permutation distributions; we might have to settle for returning an empirical p-value for such pairs.

