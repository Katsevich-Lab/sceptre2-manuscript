---
title: "GPD Goodness of Fit for SCEPTRE Resampling Distributions"
author: "Gene"
date: "2022-12-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Intro

```{r, warning = FALSE, error = FALSE, message = FALSE}
library(eva)
library(tidyverse)
library(katlabutils)
library(cowplot)

sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
# load empirical distributions
resampling_dists <- readRDS(paste0(sceptre2_results_dir, "resampling_distributions/sceptre_resampling_dists.rds"))
resampling_dists[1:5, 1:6]
```

# bounded support issue
```{r}
param <- read_csv("figures/power_exploration/ks_500000_resamples_0.96_percentile/param.csv", col_names = FALSE)
param_mat <- matrix(0,5,660)
for (i in 1:660) {
  param_mat[,i] <- as.numeric(param[[i+1]][-1])
}
rownames(param_mat) <- c("location", "scale", "shape", "statistic", "p-value")
# compute the upper bound of GPD distribution
up_bd <- param_mat[1,] - param_mat[2,]/param_mat[3,]

# how many of resampling distributions exceeding the upper bound
u_max <- apply(as.matrix(resampling_dists[,(5:(4+5e5))]), 1, max)
u_min <- apply(as.matrix(resampling_dists[,(5:(4+5e5))]), 1, min)

# find the instances where gpd does not cover the whole resamples support
which(up_bd[331:660] - u_max < 0)
which(up_bd[1:330] + u_min < 0)
```




```{r}

idx <- 2
q <- 0.96
samples <- 5e5
a <- 3

# proposal 1: cube the resampling statistic

# extract percentile and no_samples
z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
plots <- list()
for(tail in c("left", "right")){
  sign_flip <- if(tail == "right") 1 else -1
  z_null_pos <- (sign_flip*z_null)^a
  u_pos <- quantile(z_null_pos, q)
  u <- sign_flip*u_pos
  
  # extract the data
  trun_data <- (z_null_pos[z_null_pos > u_pos])
  n <- sum(z_null_pos > u_pos)
  
  # method of moment
  xi_mom <- (1 - (mean(trun_data) - u_pos)^2/var(trun_data))/2
  sig_mom <- (mean(trun_data) - u_pos)*(1 - xi_mom)
  
  # first fit ks.test with estimated parameter; if there is Na, switch to simulation
  test_ks <- ks.test(trun_data, "pgpd", u_pos, sig_mom, xi_mom)
  print(is.nan(test_ks$p.value))
  print(test_ks$p.value)
  if(is.nan(test_ks$p.value)){
    sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
    # k-s test
    test_ks <- ks.test(trun_data, sim_data)
  }
  
  
  dgpd_density <- function(x) {
    (1 - q) * dgpd(sign_flip*x,
                   loc = u_pos,
                   scale = sig_mom,
                   shape = xi_mom)
  }
  
  if(tail == "right"){
    x_min <- u
    x_max <- max(z_null^a)
  } else{
    x_min <- min(z_null^a)
    x_max <- u
  }
  
  hist_full <- tibble(z_null^a) %>%
    ggplot(aes(x = z_null^a)) +
    geom_histogram(aes(y = ..density..), bins = 1000) +
    geom_vline(xintercept = u, linetype = "dashed", color = "red") +
    stat_function(fun = dgpd_density,
                  xlim = c(x_min, x_max),
                  color = "dodgerblue") +
    coord_cartesian(xlim = c(-10, 10)) +
    labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
    theme(plot.title = element_text(hjust = 0.5))
  
  hist_tail <- hist_full +
    coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
    theme(plot.title = element_blank())
  
  expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
                                 loc = u_pos,
                                 scale = sig_mom,
                                 shape = xi_mom)
  
  expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
                        loc = u_pos,
                        scale = sig_mom,
                        shape = xi_mom)
  
  qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
                    observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
    ggplot(aes(x = expected_quantile, y = observed_quantile)) +
    geom_line() +
    geom_abline(linetype = "dashed", color = "red")
  
  # plot the tail probability
  observed_tail_prob <- (10:(0.1*n))/n
  observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
  gpd_tail_prob <- 1 - as.vector(pgpd(q = observed_extreme_quantile,
                                      loc = u_pos,
                                      scale = sig_mom,
                                      shape = xi_mom))
  # plot the tail probability
  p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
                   gpd_tail_prob = gpd_tail_prob,
                   observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
                   observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
    ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
    geom_line() +
    geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
                linetype = "dashed", colour="blue")+
    geom_abline(linetype = "dashed", color = "red") +
    scale_x_continuous(trans = c("log10", "reverse")) +
    scale_y_continuous(trans = c("log10", "reverse"))
  
  # store the plot
  plots[[tail]] <- plot_grid(qq_plot,
                             p_plot,
                             ncol = 1,
                             rel_heights = c(1.5, 1.5),
                             align = "v")
  
  # compute the ratio p-value
  ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
                      observed_tail_prob / gpd_tail_prob)
}
plots
```


```{r}

# proposal 2: force gpd shape parameter to be zero

# extract percentile and no_samples
for(tail in c("left", "right")){
  sign_flip <- if(tail == "right") 1 else -1
  z_null_pos <- (sign_flip*z_null)
  u_pos <- quantile(z_null_pos, q)
  u <- sign_flip*u_pos
  
  # extract the data
  trun_data <- (z_null_pos[z_null_pos > u_pos])
  n <- sum(z_null_pos > u_pos)
  
  # method of moment
  xi_mom <- (1 - (mean(trun_data) - u_pos)^2/var(trun_data))/2
  sig_mom <- (mean(trun_data) - u_pos)*(1 - xi_mom)
  if(xi_mom < 0){
    xi_mom <- 0
  }
  
  # first fit ks.test with estimated parameter; if there is Na, switch to simulation
  test_ks <- ks.test(trun_data, "pgpd", u_pos, sig_mom, xi_mom)
  print(is.nan(test_ks$p.value))
  print(test_ks$p.value)
  if(is.nan(test_ks$p.value)){
    sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
    # k-s test
    test_ks <- ks.test(trun_data, sim_data)
  }
  
  
  dgpd_density <- function(x) {
    (1 - q) * dgpd(sign_flip*x,
                   loc = u_pos,
                   scale = sig_mom,
                   shape = xi_mom)
  }
  
  if(tail == "right"){
    x_min <- u
    x_max <- max(z_null)
  } else{
    x_min <- min(z_null)
    x_max <- u
  }
  
  hist_full <- tibble(z_null) %>%
    ggplot(aes(x = z_null)) +
    geom_histogram(aes(y = ..density..), bins = 1000) +
    geom_vline(xintercept = u, linetype = "dashed", color = "red") +
    stat_function(fun = dgpd_density,
                  xlim = c(x_min, x_max),
                  color = "dodgerblue") +
    labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
    theme(plot.title = element_text(hjust = 0.5))
  
  hist_tail <- hist_full +
    coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
    theme(plot.title = element_blank())
  
  expected_quantiles_pos <- qgpd(p = (2*(1:n)-1)/(2*n),
                                 loc = u_pos,
                                 scale = sig_mom,
                                 shape = xi_mom)
  
  expected_unif <- pgpd(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
                        loc = u_pos,
                        scale = sig_mom,
                        shape = xi_mom)
  
  qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
                    observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
    ggplot(aes(x = expected_quantile, y = observed_quantile)) +
    geom_line() +
    geom_abline(linetype = "dashed", color = "red")
  
  # plot the tail probability
  observed_tail_prob <- (10:(0.1*n))/n
  observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
  gpd_tail_prob <- 1 - as.vector(pgpd(q = observed_extreme_quantile,
                                      loc = u_pos,
                                      scale = sig_mom,
                                      shape = xi_mom))
  # plot the tail probability
  p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
                   gpd_tail_prob = gpd_tail_prob,
                   observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
                   observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
    ggplot(aes(x = gpd_tail_prob, y = observed_tail_prob)) +
    geom_line() +
    geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
                linetype = "dashed", colour="blue")+
    geom_abline(linetype = "dashed", color = "red") +
    scale_x_continuous(trans = c("log10", "reverse")) +
    scale_y_continuous(trans = c("log10", "reverse"))
  
  # store the plot
  plots[[tail]] <- plot_grid(qq_plot,
                             p_plot,
                             ncol = 1,
                             rel_heights = c(1.5, 1.5),
                             align = "v")
  
  # compute the ratio p-value
  ratio_pvalue <- max(gpd_tail_prob / observed_tail_prob,
                      observed_tail_prob / gpd_tail_prob)
}
plots
```

```{r}

# proposal 3: fit Pareto distribution
library(EnvStats)


q <- 0.96
samples <- 5e5

working_dir <- getwd()
subDir <- sprintf("figures/power_exploration/Pareto_%d_resamples_%.2f_percentile",  samples, q)
dir.create(file.path(working_dir, subDir))
    
# create gpd parameter matrix
pareto_param <- list(left = matrix(0, nrow = 5, ncol = nrow(resampling_dists)),
                     right = matrix(0, nrow = 5, ncol = nrow(resampling_dists)))
    
for (l in 1:nrow(resampling_dists)){
  # extract index of resampling distribution
  idx <- l
  z_null <- as.numeric(resampling_dists[idx,5:(4+samples)])
      
  plots <- list()
      
  for(tail in c("left", "right")){
    sign_flip <- if(tail == "right") 1 else -1
    z_null_pos <- (sign_flip*z_null)
    u_pos <- quantile(z_null_pos, q)
    u <- sign_flip*u_pos
  
    # extract the data
    trun_data <- (z_null_pos[z_null_pos > u_pos])
    n <- sum(z_null_pos > u_pos)
  
    # explicity MLE for Pareto fit
    x_mle <- min(trun_data)
    alpha_mle <- n / (sum(log(trun_data / x_mle)))
  
    # first fit ks.test with estimated parameter; if there is Na, switch to simulation
    test_ks <- ks.test(trun_data, "ppareto", x_mle, alpha_mle)
    print(is.nan(test_ks$p.value))
    print(test_ks$p.value)
    # if(is.nan(test_ks$p.value)){
    #   sim_data <- rgpd(1e6, loc = u_pos, scale = sig_mom, shape = xi_mom)
    #   # k-s test
    #   test_ks <- ks.test(trun_data, sim_data)
    # }
  
  
    dpareto_density <- function(x) {
      (1 - q) * dpareto(sign_flip*x,
                     location = x_mle,
                     shape = alpha_mle)
    }
  
    if(tail == "right"){
      x_min <- u
      x_max <- max(z_null)
    } else{
      x_min <- min(z_null)
      x_max <- u
    }
  
    hist_full <- tibble(z_null) %>%
      ggplot(aes(x = z_null)) +
      geom_histogram(aes(y = ..density..), bins = 1000) +
      geom_vline(xintercept = u, linetype = "dashed", color = "red") +
      stat_function(fun = dgpd_density,
                    xlim = c(x_min, x_max),
                    color = "dodgerblue")
  
    hist_tail <- hist_full +
      coord_cartesian(xlim = c(x_min, x_max), ylim = c(0, dgpd_density(u)*1.5)) +
      theme(plot.title = element_blank()) +
      labs(title = sprintf("Stat = %0.4f, p = %0.1e", sqrt(test_ks$statistic/n), test_ks$p.value)) +
      theme(plot.title = element_text(hjust = 0.5))
  
    expected_quantiles_pos <- qpareto(p = (2*(1:n)-1)/(2*n),
                                   location = x_mle,
                                   shape = alpha_mle)
  
    expected_unif <- ppareto(q = sort(sign_flip*z_null_pos[z_null_pos > u_pos]),
                          location = x_mle,
                          shape = alpha_mle)
  
    qq_plot <- tibble(expected_quantile = sort(sign_flip*expected_quantiles_pos),
                      observed_quantile = sort(sign_flip*z_null_pos[z_null_pos > u_pos])) %>%
      ggplot(aes(x = expected_quantile, y = observed_quantile)) +
      geom_line() +
      geom_abline(linetype = "dashed", color = "red")
  
    # plot the tail probability
    observed_tail_prob <- (10:(0.1*n))/n
    observed_extreme_quantile <- quantile(trun_data, 1 - observed_tail_prob)
    pareto_tail_prob <- 1 - as.vector(ppareto(q = observed_extreme_quantile,
                                      location = x_mle,
                                      shape = alpha_mle))
    # plot the tail probability
    p_plot <- tibble(observed_tail_prob = as.vector(observed_tail_prob),
                     pareto_tail_prob = pareto_tail_prob,
                     observed_prob_ub = observed_tail_prob + 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n),
                     observed_prob_lb = observed_tail_prob - 1.96*sqrt(observed_tail_prob*(1-observed_tail_prob)/n)) %>%
      ggplot(aes(x = pareto_tail_prob, y = observed_tail_prob)) +
      geom_line() +
      geom_ribbon(aes(ymin = observed_prob_lb, ymax = observed_prob_ub), alpha=0.0,
                  linetype = "dashed", colour="blue")+
      geom_abline(linetype = "dashed", color = "red") +
      scale_x_continuous(trans = c("log10", "reverse")) +
      scale_y_continuous(trans = c("log10", "reverse"))
  
    # store the plot
    plots[[tail]] <- plot_grid(hist_tail,
                               qq_plot,
                               p_plot,
                               ncol = 1,
                               rel_heights = c(2, 1.5, 1.5),
                               align = "v")
  
    # compute the ratio p-value
    ratio_pvalue <- max(pareto_tail_prob / observed_tail_prob,
                        observed_tail_prob / pareto_tail_prob)
    print(ratio_pvalue)
    # save the gpd parameters and gof statistics and p-value
    pareto_param[[which(names(pareto_param) == tail)]][1, l] <- x_mle
    pareto_param[[which(names(pareto_param) == tail)]][2, l] <- alpha_mle
    pareto_param[[which(names(pareto_param) == tail)]][3, l] <- test_ks$statistic
    pareto_param[[which(names(pareto_param) == tail)]][4, l] <- test_ks$p.value
    pareto_param[[which(names(pareto_param) == tail)]][5, l] <- ratio_pvalue
    }
      
    # plot
    final_plot <- plot_grid(plots[["left"]], plots[["right"]])
      
    # save the plot in specific folder
    save_plot(sprintf("%s/%d.pdf", file.path(working_dir, subDir), idx), final_plot)
    print(l)
}
# save the gpd parameter matrix and goodness of fit statistic and p-value
write.csv(gpd_param, sprintf("%s/param.csv", file.path(working_dir, subDir)))


```
