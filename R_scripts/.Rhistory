all_nt_idxs = grna_assignments$all_nt_idxs,
regression_method = regression_method,
indiv_nt_grna_idxs = if (calibration_check) grna_assignments$indiv_nt_grna_idxs else NA)
SE_THRESH <- 15.0
# 1. obtain the subset of the covariate matrix corresponding to the NT cells and n_cells
covariate_matrix_nt <- covariate_matrix[grna_assignments$all_nt_idxs,]
n_cells <- ncol(response_matrix)
response_id <- as.character(response_ids[response_idx])
# 3. load the expressions of the current response; also get the nt expression vector
expression_vector <- load_csr_row(j = response_matrix@j,
p = response_matrix@p,
x = response_matrix@x,
row_idx = which(rownames(response_matrix) == response_id),
n_cells = n_cells)
expression_vector_nt <- expression_vector[grna_assignments$all_nt_idxs]
# 4. obtain the gRNA groups to analyze
l <- response_grna_group_pairs$response_id == response_id
curr_df <- response_grna_group_pairs[l,]
# 5. if running a discovery analysis, do QC
if (!calibration_check) {
n_nonzero_cntrl_curr <- sum(expression_vector_nt >= 1)
grna_group_posits <- match(x = curr_df$grna_group, table = names(grna_assignments$grna_group_idxs))
n_nonzero_trt_curr <- compute_n_nonzero_trt_vector(expression_vector = expression_vector,
grna_group_idxs = grna_assignments$grna_group_idxs,
grna_group_posits = grna_group_posits)
curr_df$n_nonzero_trt <- n_nonzero_trt_curr
curr_df$n_nonzero_cntrl <- n_nonzero_cntrl_curr
pass_qc <- n_nonzero_trt_curr >= n_nonzero_trt_thresh
# i. if n_nonzero_cntrl_curr is less than n_nonzero_cntrl_thresh, jump to next iteration
if (n_nonzero_cntrl_curr < n_nonzero_cntrl_thresh || !any(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df
out_counter <- out_counter + 1L
next
}
# ii. remove any rows that have not passed qc; keep the rows that have passed qc
if (!all(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df[!pass_qc,]
out_counter <- out_counter + 1L
}
curr_df <- curr_df[pass_qc,]
}
# 6. perform the expression on technical factor regression
response_precomp <- perform_response_precomputation(expressions = expression_vector_nt,
covariate_matrix = covariate_matrix_nt,
regression_method = regression_method)
# 7. obtain precomputation peices for NT cells
pieces_precomp <- compute_precomputation_pieces(expression_vector_nt,
covariate_matrix_nt,
response_precomp$fitted_coefs,
response_precomp$theta,
full_test_stat = TRUE)
response_precomp
# 8. verify that the regression coefficients are high precision
low_level_association_funct <- "lowmoi_approximate_stat_discovery"
regression_ses <- compute_regression_ses(covariate_matrix_nt = covariate_matrix_nt,
w = pieces_precomp$w)
regression_ses
if (!calibration_check) {
# 8. verify that the regression coefficients are high precision
low_level_association_funct <- "lowmoi_approximate_stat_discovery"
regression_ses <- compute_regression_ses(covariate_matrix_nt = covariate_matrix_nt,
w = pieces_precomp$w)
if (any(regression_ses >= SE_THRESH)) low_level_association_funct <- "lowmoi_exact_stat_discovery"
} else {
low_level_association_funct <- "lowmoi_undercover_stat"
}
args_to_pass$grna_groups <- as.character(curr_df$grna_group)
args_to_pass$pieces_precomp <- pieces_precomp
args_to_pass$expression_vector_nt <- expression_vector_nt
args_to_pass$expression_vector <- expression_vector
args_to_pass$response_precomp <- response_precomp
# 9. pass the arguments to the appropriate low-level association testing function
curr_response_result <- do.call(what = low_level_association_funct, args = args_to_pass)
construct_data_frame_v2(curr_df, curr_response_result,
return_debugging_metrics, return_resampling_dist,
response_precomp$precomp_str, low_level_association_funct)
low_level_association_funct
low_level_association_funct <- "lowmoi_exact_stat_discovery"
# 9. pass the arguments to the appropriate low-level association testing function
curr_response_result <- do.call(what = low_level_association_funct, args = args_to_pass)
construct_data_frame_v2(curr_df, curr_response_result,
return_debugging_metrics, return_resampling_dist,
response_precomp$precomp_str, low_level_association_funct)
# fit Poisson model, tracking warning
pois_warn <- FALSE
wHandler <- function(w) {pois_warn <<- TRUE; invokeRestart("muffleWarning")}
withCallingHandlers(expr = {
pois_fit <- stats::glm.fit(y = expressions, x = covariate_matrix, family = stats::poisson())
}, warning = wHandler)
expressions
# backup: return fitted coefficients from Poisson regression
backup_2 <- function(pois_fit, pois_warn) {
list(fitted_coef_str = paste0("pois", if (pois_warn) "_(warn)" else NULL),
fitted_coefs = pois_fit$coefficients)
}
# fit Poisson model, tracking warning
pois_warn <- FALSE
wHandler <- function(w) {pois_warn <<- TRUE; invokeRestart("muffleWarning")}
expressions = expression_vector_nt
covariate_matrix = covariate_matrix_nt
regression_method = regression_method
# backup: return fitted coefficients from Poisson regression
backup_2 <- function(pois_fit, pois_warn) {
list(fitted_coef_str = paste0("pois", if (pois_warn) "_(warn)" else NULL),
fitted_coefs = pois_fit$coefficients)
}
# fit Poisson model, tracking warning
pois_warn <- FALSE
wHandler <- function(w) {pois_warn <<- TRUE; invokeRestart("muffleWarning")}
withCallingHandlers(expr = {
pois_fit <- stats::glm.fit(y = expressions, x = covariate_matrix, family = stats::poisson())
}, warning = wHandler)
# get theta; save theta itself (in response_theta) and theta_fit_string (i.e., procedure used to fit theta)
response_theta_list <- estimate_theta(y = expressions, mu = pois_fit$fitted.values, dfr = pois_fit$df.residual,
limit = 50, eps = (.Machine$double.eps)^(1/4))
theta_fit_str <- c("mle", "mm", "pilot")[response_theta_list[[2]]]
theta <- max(min(response_theta_list[[1]], 1000), 0.01)
pois_fit
pois_fit <- stats::glm(y = expressions, x = covariate_matrix, family = stats::poisson())
pois_fit <- stats::glm(y = expressions, x = as.data.frame(covariate_matrix), family = stats::poisson())
pois_fit <- stats::glm(y = expressions ~ . + 0, x = as.data.frame(covariate_matrix), family = stats::poisson())
pois_fit <- stats::glm(y = expressions, formula =  expressions ~ . + 0, x = as.data.frame(covariate_matrix), family = stats::poisson())
pois_fit <- stats::glm(expressions ~ . + 0, data = as.data.frame(covariate_matrix), family = stats::poisson())
poit_fit
pois_fit
summary(pois_fit)
mean(covariate_matrix[,"batchsample9"])
0.101773/mean(covariate_matrix[,"batchsample9"])
# 2. loop over the response IDs
response_ids <- unique(response_grna_group_pairs$response_id)
head(response_ids)
response_idx <- 1
response_id <- as.character(response_ids[response_idx])
# 3. load the expressions of the current response; also get the nt expression vector
expression_vector <- load_csr_row(j = response_matrix@j,
p = response_matrix@p,
x = response_matrix@x,
row_idx = which(rownames(response_matrix) == response_id),
n_cells = n_cells)
expression_vector_nt <- expression_vector[grna_assignments$all_nt_idxs]
# 4. obtain the gRNA groups to analyze
l <- response_grna_group_pairs$response_id == response_id
curr_df <- response_grna_group_pairs[l,]
# 5. if running a discovery analysis, do QC
if (!calibration_check) {
n_nonzero_cntrl_curr <- sum(expression_vector_nt >= 1)
grna_group_posits <- match(x = curr_df$grna_group, table = names(grna_assignments$grna_group_idxs))
n_nonzero_trt_curr <- compute_n_nonzero_trt_vector(expression_vector = expression_vector,
grna_group_idxs = grna_assignments$grna_group_idxs,
grna_group_posits = grna_group_posits)
curr_df$n_nonzero_trt <- n_nonzero_trt_curr
curr_df$n_nonzero_cntrl <- n_nonzero_cntrl_curr
pass_qc <- n_nonzero_trt_curr >= n_nonzero_trt_thresh
# i. if n_nonzero_cntrl_curr is less than n_nonzero_cntrl_thresh, jump to next iteration
if (n_nonzero_cntrl_curr < n_nonzero_cntrl_thresh || !any(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df
out_counter <- out_counter + 1L
next
}
# ii. remove any rows that have not passed qc; keep the rows that have passed qc
if (!all(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df[!pass_qc,]
out_counter <- out_counter + 1L
}
curr_df <- curr_df[pass_qc,]
}
# 6. perform the expression on technical factor regression
response_precomp <- perform_response_precomputation(expressions = expression_vector_nt,
covariate_matrix = covariate_matrix_nt,
regression_method = regression_method)
# 7. obtain precomputation peices for NT cells
pieces_precomp <- compute_precomputation_pieces(expression_vector_nt,
covariate_matrix_nt,
response_precomp$fitted_coefs,
response_precomp$theta,
full_test_stat = TRUE)
# 8. verify that the regression coefficients are high precision
low_level_association_funct <- "lowmoi_approximate_stat_discovery"
regression_ses <- compute_regression_ses(covariate_matrix_nt = covariate_matrix_nt,
w = pieces_precomp$w)
regression_ses
idx
response_idx
response_idx <- 2
if ((response_idx == 1 || response_idx %% 5 == 0) && print_progress) {
cat(paste0("Analyzing pairs containing response ", as.character(response_ids[response_idx]), " (", response_idx, " of ", length(response_ids), ")\n"))
}
if (response_idx %% 200 == 0) gc() |> invisible()
response_id <- as.character(response_ids[response_idx])
# 3. load the expressions of the current response; also get the nt expression vector
expression_vector <- load_csr_row(j = response_matrix@j,
p = response_matrix@p,
x = response_matrix@x,
row_idx = which(rownames(response_matrix) == response_id),
n_cells = n_cells)
expression_vector_nt <- expression_vector[grna_assignments$all_nt_idxs]
# 4. obtain the gRNA groups to analyze
l <- response_grna_group_pairs$response_id == response_id
curr_df <- response_grna_group_pairs[l,]
# 5. if running a discovery analysis, do QC
if (!calibration_check) {
n_nonzero_cntrl_curr <- sum(expression_vector_nt >= 1)
grna_group_posits <- match(x = curr_df$grna_group, table = names(grna_assignments$grna_group_idxs))
n_nonzero_trt_curr <- compute_n_nonzero_trt_vector(expression_vector = expression_vector,
grna_group_idxs = grna_assignments$grna_group_idxs,
grna_group_posits = grna_group_posits)
curr_df$n_nonzero_trt <- n_nonzero_trt_curr
curr_df$n_nonzero_cntrl <- n_nonzero_cntrl_curr
pass_qc <- n_nonzero_trt_curr >= n_nonzero_trt_thresh
# i. if n_nonzero_cntrl_curr is less than n_nonzero_cntrl_thresh, jump to next iteration
if (n_nonzero_cntrl_curr < n_nonzero_cntrl_thresh || !any(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df
out_counter <- out_counter + 1L
next
}
# ii. remove any rows that have not passed qc; keep the rows that have passed qc
if (!all(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df[!pass_qc,]
out_counter <- out_counter + 1L
}
curr_df <- curr_df[pass_qc,]
}
# 6. perform the expression on technical factor regression
response_precomp <- perform_response_precomputation(expressions = expression_vector_nt,
covariate_matrix = covariate_matrix_nt,
regression_method = regression_method)
# 7. obtain precomputation peices for NT cells
pieces_precomp <- compute_precomputation_pieces(expression_vector_nt,
covariate_matrix_nt,
response_precomp$fitted_coefs,
response_precomp$theta,
full_test_stat = TRUE)
if (!calibration_check) {
# 8. verify that the regression coefficients are high precision
low_level_association_funct <- "lowmoi_approximate_stat_discovery"
regression_ses <- compute_regression_ses(covariate_matrix_nt = covariate_matrix_nt,
w = pieces_precomp$w)
if (any(regression_ses >= SE_THRESH)) low_level_association_funct <- "lowmoi_exact_stat_discovery"
} else {
low_level_association_funct <- "lowmoi_undercover_stat"
}
regression_ses
response_idx <- 3
if ((response_idx == 1 || response_idx %% 5 == 0) && print_progress) {
cat(paste0("Analyzing pairs containing response ", as.character(response_ids[response_idx]), " (", response_idx, " of ", length(response_ids), ")\n"))
}
if (response_idx %% 200 == 0) gc() |> invisible()
response_id <- as.character(response_ids[response_idx])
# 3. load the expressions of the current response; also get the nt expression vector
expression_vector <- load_csr_row(j = response_matrix@j,
p = response_matrix@p,
x = response_matrix@x,
row_idx = which(rownames(response_matrix) == response_id),
n_cells = n_cells)
expression_vector_nt <- expression_vector[grna_assignments$all_nt_idxs]
# 4. obtain the gRNA groups to analyze
l <- response_grna_group_pairs$response_id == response_id
curr_df <- response_grna_group_pairs[l,]
# 5. if running a discovery analysis, do QC
if (!calibration_check) {
n_nonzero_cntrl_curr <- sum(expression_vector_nt >= 1)
grna_group_posits <- match(x = curr_df$grna_group, table = names(grna_assignments$grna_group_idxs))
n_nonzero_trt_curr <- compute_n_nonzero_trt_vector(expression_vector = expression_vector,
grna_group_idxs = grna_assignments$grna_group_idxs,
grna_group_posits = grna_group_posits)
curr_df$n_nonzero_trt <- n_nonzero_trt_curr
curr_df$n_nonzero_cntrl <- n_nonzero_cntrl_curr
pass_qc <- n_nonzero_trt_curr >= n_nonzero_trt_thresh
# i. if n_nonzero_cntrl_curr is less than n_nonzero_cntrl_thresh, jump to next iteration
if (n_nonzero_cntrl_curr < n_nonzero_cntrl_thresh || !any(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df
out_counter <- out_counter + 1L
next
}
# ii. remove any rows that have not passed qc; keep the rows that have passed qc
if (!all(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df[!pass_qc,]
out_counter <- out_counter + 1L
}
curr_df <- curr_df[pass_qc,]
}
# 6. perform the expression on technical factor regression
response_precomp <- perform_response_precomputation(expressions = expression_vector_nt,
covariate_matrix = covariate_matrix_nt,
regression_method = regression_method)
# 7. obtain precomputation peices for NT cells
pieces_precomp <- compute_precomputation_pieces(expression_vector_nt,
covariate_matrix_nt,
response_precomp$fitted_coefs,
response_precomp$theta,
full_test_stat = TRUE)
if (!calibration_check) {
# 8. verify that the regression coefficients are high precision
low_level_association_funct <- "lowmoi_approximate_stat_discovery"
regression_ses <- compute_regression_ses(covariate_matrix_nt = covariate_matrix_nt,
w = pieces_precomp$w)
if (any(regression_ses >= SE_THRESH)) low_level_association_funct <- "lowmoi_exact_stat_discovery"
} else {
low_level_association_funct <- "lowmoi_undercover_stat"
}
regression_ses
?run_sceptre_lowmoi
library(Matrix)
# 0. load the data associated with the experiment
data(response_matrix_lowmoi) # response-by-cell expression matrix
data(grna_matrix_lowmoi) # gRNA-by-cell expression matrix
data(covariate_data_frame_lowmoi) # cell-by-covariate data frame
data(grna_group_data_frame_lowmoi) # gRNA group information
# 1. obtain the set of pairs to analyze
response_grna_group_pairs <- generate_all_pairs(response_matrix_lowmoi,
grna_group_data_frame_lowmoi)
# 2. set the formula object
formula_object <- formula(~log(response_n_umis) + log(response_n_nonzero) +
bio_rep + p_mito)
response_matrix = response_matrix_lowmoi
grna_matrix = grna_matrix_lowmoi
covariate_data_frame = covariate_data_frame_lowmoi
grna_group_data_frame = grna_group_data_frame_lowmoi
formula_object = formula_object
response_grna_group_pairs = response_grna_group_pairs
calibration_check = TRUE
n_nonzero_trt_thresh = 7L
n_nonzero_cntrl_thresh = 7L; return_debugging_metrics = FALSE
return_resampling_dist = FALSE; fit_skew_normal = TRUE
calibration_group_size = NULL; n_calibration_pairs = NULL
B1 = 499L; B2 = 4999L; B3 = 24999L; regression_method = "poisson_glm"
print_progress = TRUE
###############
# PART 1: SETUP
###############
cat("Running setup. ")
# 1. check function input arguments
check_inputs(response_matrix, grna_matrix, covariate_data_frame, grna_group_data_frame,
formula_object, calibration_check, response_grna_group_pairs, regression_method) |> invisible()
# 2. harmonize arguments (called for side-effect)
harmonize_arguments(return_resampling_dist, fit_skew_normal) |> invisible()
# 3. cast and transpose response matrix; cast grna matrix
response_matrix <- set_matrix_accessibility(response_matrix, TRUE)
# 4. convert the cell covariate data frame into a design matrix
covariate_matrix <- convert_covariate_df_to_design_matrix(covariate_data_frame, formula_object)
rm(covariate_data_frame)
# 5. assign the gRNAs to cells
grna_assignments <- assign_grnas_to_cells_lowmoi_v2(grna_matrix, grna_group_data_frame, calibration_check, n_calibration_pairs)
rm(grna_matrix)
cat(crayon::green(' \u2713\n'))
# 6. construct the undercover response_grna_group_pairs
if (calibration_check) {
cat("Constructing negative control pairs.")
if (is.null(calibration_group_size)) calibration_group_size <- compute_calibration_group_size(grna_group_data_frame)
response_grna_group_pairs <- construct_negative_control_pairs(n_calibration_pairs, calibration_group_size, grna_assignments, response_matrix, n_nonzero_trt_thresh, n_nonzero_cntrl_thresh, grna_group_data_frame, response_grna_group_pairs)
cat(crayon::green(' \u2713\n'))
}
# 7. generate the set of synthetic indicator idxs
cat("Generating permutation resamples.")
synthetic_idxs <- get_synthetic_idxs_lowmoi(grna_assignments, B1 + B2 + B3, calibration_check, calibration_group_size)
cat(crayon::green(' \u2713\n'))
gc() |> invisible()
####################
# PART 2: RUN METHOD
####################
cat("Running differential expression analyses.\n")
calibration_Check
calibration_check
# 0. preliminary setup; initialize the args_to_pass, set the low_level_association_funct
result_list_outer <- vector(mode = "list", length = 2 * length(unique(response_grna_group_pairs$response_id)))
out_counter <- 1L
args_to_pass <- list(synthetic_idxs = synthetic_idxs, B1 = B1, B2 = B2, B3 = B3,
fit_skew_normal = fit_skew_normal,
return_resampling_dist = return_resampling_dist,
grna_group_idxs = grna_assignments$grna_group_idxs,
covariate_matrix = covariate_matrix,
all_nt_idxs = grna_assignments$all_nt_idxs,
regression_method = regression_method,
indiv_nt_grna_idxs = if (calibration_check) grna_assignments$indiv_nt_grna_idxs else NA)
SE_THRESH <- 15.0
# 1. obtain the subset of the covariate matrix corresponding to the NT cells and n_cells
covariate_matrix_nt <- covariate_matrix[grna_assignments$all_nt_idxs,]
n_cells <- ncol(response_matrix)
# 2. loop over the response IDs
response_ids <- unique(response_grna_group_pairs$response_id)
response_idx <- 1
if ((response_idx == 1 || response_idx %% 5 == 0) && print_progress) {
cat(paste0("Analyzing pairs containing response ", as.character(response_ids[response_idx]), " (", response_idx, " of ", length(response_ids), ")\n"))
}
if (response_idx %% 200 == 0) gc() |> invisible()
response_id <- as.character(response_ids[response_idx])
# 3. load the expressions of the current response; also get the nt expression vector
expression_vector <- load_csr_row(j = response_matrix@j,
p = response_matrix@p,
x = response_matrix@x,
row_idx = which(rownames(response_matrix) == response_id),
n_cells = n_cells)
expression_vector_nt <- expression_vector[grna_assignments$all_nt_idxs]
# 4. obtain the gRNA groups to analyze
l <- response_grna_group_pairs$response_id == response_id
curr_df <- response_grna_group_pairs[l,]
# 5. if running a discovery analysis, do QC
if (!calibration_check) {
n_nonzero_cntrl_curr <- sum(expression_vector_nt >= 1)
grna_group_posits <- match(x = curr_df$grna_group, table = names(grna_assignments$grna_group_idxs))
n_nonzero_trt_curr <- compute_n_nonzero_trt_vector(expression_vector = expression_vector,
grna_group_idxs = grna_assignments$grna_group_idxs,
grna_group_posits = grna_group_posits)
curr_df$n_nonzero_trt <- n_nonzero_trt_curr
curr_df$n_nonzero_cntrl <- n_nonzero_cntrl_curr
pass_qc <- n_nonzero_trt_curr >= n_nonzero_trt_thresh
# i. if n_nonzero_cntrl_curr is less than n_nonzero_cntrl_thresh, jump to next iteration
if (n_nonzero_cntrl_curr < n_nonzero_cntrl_thresh || !any(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df
out_counter <- out_counter + 1L
next
}
# ii. remove any rows that have not passed qc; keep the rows that have passed qc
if (!all(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df[!pass_qc,]
out_counter <- out_counter + 1L
}
curr_df <- curr_df[pass_qc,]
}
# 6. perform the expression on technical factor regression
response_precomp <- perform_response_precomputation(expressions = expression_vector_nt,
covariate_matrix = covariate_matrix_nt,
regression_method = regression_method)
# 7. obtain precomputation peices for NT cells
pieces_precomp <- compute_precomputation_pieces(expression_vector_nt,
covariate_matrix_nt,
response_precomp$fitted_coefs,
response_precomp$theta,
full_test_stat = TRUE)
# 8. verify that the regression coefficients are high precision
low_level_association_funct <- "lowmoi_approximate_stat_discovery"
regression_ses <- compute_regression_ses(covariate_matrix_nt = covariate_matrix_nt,
w = pieces_precomp$w)
regression_ses
covariate_matrix |> head()
covariate_matrix[,"p_mito"] |> mean()
24.3713081 / 0.03675319
covariate_matrix[,"bio_reprep_2"] |> mean()
0.8365028 /0.2894978
regression_ses["bio_reprep_3"] / (covariate_matrix[,"bio_reprep_3"] |> mean())
regression_ses["response_n_umis"] / (covariate_matrix[,"response_n_umis"] |> mean())
regression_ses["log(response_n_umis)"] / (covariate_matrix[,"log(response_n_umis)"] |> mean())
regression_ses["log(response_n_nonzero)"] / (covariate_matrix[,"log(response_n_nonzero)"] |> mean())
regression_ses
response_precomp
regression_ses["log(bio_reprep_2)"] / (covariate_matrix[,"bio_reprep_2"] |> mean())
regression_ses["bio_reprep_2"] / (covariate_matrix[,"bio_reprep_2"] |> mean())
regression_ses["bio_reprep_3"] / (covariate_matrix[,"bio_reprep_3"] |> mean())
response_idx
response_idx <- 2
if ((response_idx == 1 || response_idx %% 5 == 0) && print_progress) {
cat(paste0("Analyzing pairs containing response ", as.character(response_ids[response_idx]), " (", response_idx, " of ", length(response_ids), ")\n"))
}
if (response_idx %% 200 == 0) gc() |> invisible()
response_id <- as.character(response_ids[response_idx])
# 3. load the expressions of the current response; also get the nt expression vector
expression_vector <- load_csr_row(j = response_matrix@j,
p = response_matrix@p,
x = response_matrix@x,
row_idx = which(rownames(response_matrix) == response_id),
n_cells = n_cells)
expression_vector_nt <- expression_vector[grna_assignments$all_nt_idxs]
# 4. obtain the gRNA groups to analyze
l <- response_grna_group_pairs$response_id == response_id
curr_df <- response_grna_group_pairs[l,]
# 5. if running a discovery analysis, do QC
if (!calibration_check) {
n_nonzero_cntrl_curr <- sum(expression_vector_nt >= 1)
grna_group_posits <- match(x = curr_df$grna_group, table = names(grna_assignments$grna_group_idxs))
n_nonzero_trt_curr <- compute_n_nonzero_trt_vector(expression_vector = expression_vector,
grna_group_idxs = grna_assignments$grna_group_idxs,
grna_group_posits = grna_group_posits)
curr_df$n_nonzero_trt <- n_nonzero_trt_curr
curr_df$n_nonzero_cntrl <- n_nonzero_cntrl_curr
pass_qc <- n_nonzero_trt_curr >= n_nonzero_trt_thresh
# i. if n_nonzero_cntrl_curr is less than n_nonzero_cntrl_thresh, jump to next iteration
if (n_nonzero_cntrl_curr < n_nonzero_cntrl_thresh || !any(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df
out_counter <- out_counter + 1L
next
}
# ii. remove any rows that have not passed qc; keep the rows that have passed qc
if (!all(pass_qc)) {
result_list_outer[[out_counter]] <- curr_df[!pass_qc,]
out_counter <- out_counter + 1L
}
curr_df <- curr_df[pass_qc,]
}
# 6. perform the expression on technical factor regression
response_precomp <- perform_response_precomputation(expressions = expression_vector_nt,
covariate_matrix = covariate_matrix_nt,
regression_method = regression_method)
# 7. obtain precomputation peices for NT cells
pieces_precomp <- compute_precomputation_pieces(expression_vector_nt,
covariate_matrix_nt,
response_precomp$fitted_coefs,
response_precomp$theta,
full_test_stat = TRUE)
!calibration_check
if (!calibration_check) {
# 8. verify that the regression coefficients are high precision
low_level_association_funct <- "lowmoi_approximate_stat_discovery"
regression_ses <- compute_regression_ses(covariate_matrix_nt = covariate_matrix_nt,
w = pieces_precomp$w)
if (any(regression_ses >= SE_THRESH)) low_level_association_funct <- "lowmoi_exact_stat_discovery"
} else {
low_level_association_funct <- "lowmoi_undercover_stat"
}
regression_ses
regression_ses["bio_reprep_3"] / (covariate_matrix[,"bio_reprep_3"] |> mean())
regression_ses["bio_reprep_2"] / (covariate_matrix[,"bio_reprep_2"] |> mean())
load_all()
