index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
# compute theoretical and empirical p-values
p_theory <- 2 * pnorm(q = -abs(z_star), lower.tail = TRUE)
p_camp <- lowmoi:::compute_empirical_p_value(z_star = z_star, z_null = z_null, "both")
# finally, compute permutation
ts <- lowmoi:::low_level_permutation_test(y = y, index_mat = idx_mat)
t_star <- ts[1]
t_null <- ts[-1]
p_perm <- lowmoi:::compute_empirical_p_value(t_star, t_null, "both")
out_m[i,] <- c(p_theory = p_theory, p_camp = p_camp, p_perm = p_perm)
if (i == 1) {
resamp_dist[["camp_null"]] <- z_null
resamp_dist[["camp_star"]] <- z_star
resamp_dist[["perm_null"]] <- ts
resamp_dist[["perm_star"]] <- t_star
}
}
colnames(out_m) <- c("p_theory", "p_camp", "p_perm")
return(list(out_m = out_m, resamp_dist = resamp_dist))
}
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
n_sim <- 2000
set.seed(3)
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# keep x fixed
x_idx <- which(orig_x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(orig_x), size = sum(orig_x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
sim_res_correlated_corret_model <- run_simulation(Y = Y, idx_mat = idx_mat,
Z = Z, theta_hypothesized = theta,
return_null_dist = TRUE, approx = FALSE)
lowmoi:::low_level_score_test_vectorized()
lowmoi:::low_level_score_test_vectorized
Y = Y; idx_mat = idx_mat
Z = Z; theta_hypothesized = theta
return_null_dist = TRUE; approx = FALSE
resamp_dist <- list()
if (is.null(n_sim)) n_sim <- ncol(Y)
out_m <- matrix(nrow = n_sim, ncol = 3)
i <- 1L
print(paste0("Running simulation ", i))
y <- Y[,i]
# regress the synthetic Y onto Z
fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta_hypothesized))
i == 1 || !approx
# extract z-scores
if (i == 1 || !approx) {
z_scores <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
# extract z-scores
if (i == 1 || !approx) {
z_scores <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
i == 1 || !approx
z_scores <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
lowmoi:::run_glm_perm_score_test_with_ingredients
Z = Z
working_resid = fit$residuals
w = fit$weights
index_mat = idx_mat
load_all("~/research_code/lowmoi")
z_scores <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
# compute Z^T w (to be used throughout)
ZtW <- sapply(X = seq(1, length(w)), FUN = function(i) w[i] * Z[i,])
# compute the precision matrix P = Z^t W Z
P <- ZtW %*% Z
# compute the spectral decomposition of P
P_decomp <- eigen(P)
# obtain U and Lambda^(-1/2)
U <- P_decomp$vectors
Lambda_minus_half <- 1/sqrt(P_decomp$values)
# compute the matrix B = Lambda^(1/2) U^t (Z^t W)
B <- (Lambda_minus_half * t(U)) %*% ZtW
# next, compute the vector W M (Y - mu_hat)
a <- w * working_resid
# compute the vector of z-scores
z_scores <- low_level_score_test_vectorized(a = a, B = B, w = w, index_mat = index_mat)
low_level_score_test_vectorized
head(a)
head(B)
head(w)
head(index_mat)
10
low_level_score_test_vectorized
low_level_score_test_vectorized(a = a, B = B, w = w, index_mat = index_mat)
library(ondisc)
library(sceptre2)
result_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/extra_analyses/")
###########################
# STEP 1: SET UP SIMULATION
###########################
# 1. load Papalexi data
response_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/gene")
grna_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/grna_assignment")
grna_targets <- lowmoi::get_target_assignments_via_max_op(grna_odm)
# 2. get the gRNA group info
my_grna <- "CUL3"
grna_group_info <- lowmoi:::get_grna_group_info(grna_group_assignments = grna_targets,
input_grna_groups = my_grna)
idxs <- c(grna_group_info$grna_specific_idxs[[my_grna]],
grna_group_info$grna_specific_idxs[["non-targeting"]])
orig_x <- c(rep(1, grna_group_info$n_cells_per_grna[[my_grna]]),
rep(0, grna_group_info$n_cells_per_grna[["non-targeting"]]))
# 3. get covariate matrix
covariate_matrix_df <- response_odm |>
get_cell_covariates() |>
dplyr::slice(idxs) |>
dplyr::select(n_nonzero, n_umis, bio_rep, phase, p_mito)
row.names(covariate_matrix_df) <- NULL
Z <- model.matrix(object = formula(~ log(n_nonzero) + log(n_umis) + bio_rep + phase + p_mito),
data = covariate_matrix_df)
colnames(Z) <- c("intercept", "lg_n_nonzero", "lg_n_umis", "bio_rep_d1", "bio_rep_d2", "phase_d1", "phase_d2", "p_mito")
# 4. select gene
ex_gene <- "CXCL10"
orig_y <- as.numeric(response_odm[[ex_gene, idxs]])
# 5. get the model for y | Z
fit_y_orig <- MASS::glm.nb(formula = orig_y ~ . + 0, data = as.data.frame(Z))
y_coef <- coef(fit_y_orig)
theta <- fit_y_orig$theta
mus_y <- exp(as.numeric(Z %*% y_coef))
#################################
# STEP 2: RUN SIMULATION FUNCTION
#################################
run_simulation <- function(Y, idx_mat, Z, theta_hypothesized, n_sim = NULL, return_null_dist = FALSE, approx = TRUE) {
resamp_dist <- list()
if (is.null(n_sim)) n_sim <- ncol(Y)
out_m <- matrix(nrow = n_sim, ncol = 3)
for (i in seq(1, n_sim)) {
print(paste0("Running simulation ", i))
y <- Y[,i]
# regress the synthetic Y onto Z
fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta_hypothesized))
# extract z-scores
if (i == 1 || !approx) {
z_scores <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- lowmoi:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
# compute theoretical and empirical p-values
p_theory <- 2 * pnorm(q = -abs(z_star), lower.tail = TRUE)
p_camp <- lowmoi:::compute_empirical_p_value(z_star = z_star, z_null = z_null, "both")
# finally, compute permutation
ts <- lowmoi:::low_level_permutation_test(y = y, index_mat = idx_mat)
t_star <- ts[1]
t_null <- ts[-1]
p_perm <- lowmoi:::compute_empirical_p_value(t_star, t_null, "both")
out_m[i,] <- c(p_theory = p_theory, p_camp = p_camp, p_perm = p_perm)
if (i == 1) {
resamp_dist[["camp_null"]] <- z_null
resamp_dist[["camp_star"]] <- z_star
resamp_dist[["perm_null"]] <- ts
resamp_dist[["perm_star"]] <- t_star
}
}
colnames(out_m) <- c("p_theory", "p_camp", "p_perm")
return(list(out_m = out_m, resamp_dist = resamp_dist))
}
n_sim <- 2
set.seed(3)
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# keep x fixed
x_idx <- which(orig_x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(orig_x), size = sum(orig_x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
sim_res_correlated_corret_model <- run_simulation(Y = Y, idx_mat = idx_mat,
Z = Z, theta_hypothesized = theta,
return_null_dist = TRUE, approx = FALSE)
library(lowmoi)
library(tidyverse)
conflicts_prefer(dplyr::filter)
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
sample_size_df <- readRDS(paste0(sceptre2_results_dir, "dataset_sample_sizes/n_nonzero_cells_per_grna.rds"))
# undercover res grp = 1
undercover_res <- readRDS(paste0(sceptre2_results_dir, "undercover_grna_analysis/undercover_result_grp_1_0523.rds"))
undercover_res_processed <- process_undercover_result(undercover_res, sample_size_df)
# pc result
pc_res <- readRDS(paste0(sceptre2_results_dir, "positive_control_analysis/pc_results_0523.rds"))
pc_res_processed <- suppressWarnings(process_pc_result(pc_res, sample_size_df))
saveRDS(object = pc_res_processed,
file = paste0(sceptre2_results_dir, "positive_control_analysis/pc_results_0523_processed.rds"))
head(pc_res_processed)
# singleton discovery result
singleton_discovery_res <- readRDS(paste0(sceptre2_results_dir,
"discovery_analyses/discovery_results_singleton_0523.rds")) |>
dplyr::rename("grna_id" = "grna_group")
singleton_discovery_res_processed <- process_pc_result(singleton_discovery_res, sample_size_df)
# singleton discovery result
singleton_discovery_res <- readRDS(paste0(sceptre2_results_dir,
"discovery_analyses/discovery_results_singleton_0523.rds")) |>
dplyr::rename("grna_id" = "grna_group")
head(singleton_discovery_res)
head(singleton_discovery_res)
head(sample_size_df)
pc_res <- singleton_discovery_res
sample_size_df <- sample_size_df
singleton_discovery_res_processed <- process_pc_result(singleton_discovery_res, sample_size_df, singleton = TRUE)
head(singleton_discovery_res_processed)
singleton_discovery_res_processed <- suppressWarnings(process_pc_result(singleton_discovery_res,
sample_size_df, singleton = TRUE))
head(singleton_discovery_res_processed)
MAST::zlm
set.seed(4)
library(camp)
library(katlabutils)
conflicts_prefer(dplyr::filter)
library(tidyverse)
library(cowplot)
# define the parameters that control the simulation
gamma <- c(-0.6, 0.8, 0.9)
n_rep <- 500
n_cells <- 5000
mu_z <- c(0.0, 0.0)
rho <- 0.5
frac_null <- 0.9
# generate the covariate matrix
z <- cbind(1, MASS::mvrnorm(n = n_cells,
mu = c(0.0, 0.0),
Sigma = toeplitz(c(1, rho))))
mu_x <- as.numeric(binomial()$linkinv(z %*% gamma))
x <- rbinom(n = n_cells, size = 1, prob = mu_x)
covariate_matrix <- cbind(z, x)
colnames(covariate_matrix) <- c("intercept", "z1", "z2", "x")
covariate_matrix_intercept_free <- covariate_matrix[,-1]
covariate_matrix_intercept_free_x_free <- covariate_matrix[,c(-1, -4)]
# generate permutation idxs
permutations <- permute_bernoulli_treatment_vector(x)
# generate results matrix
m <- as.data.frame(matrix(nrow = n_rep, ncol = 6))
colnames(m) <- c("p_resid", "p_score", "p_lrt", "null_true", "resid_time", "score_time")
for (i in seq(1, n_rep)) {
if (i %% 5 == 0) print(i)
theta <- runif(1, 0.1, 5)
null_true <- as.logical(rbinom(1, 1, frac_null))
beta <- c(0.9, 0.1, 0.3, if (null_true) 0.0 else 0.1)
family_object <- MASS::negative.binomial(theta = theta)
y <- generate_glm_data(
design_matrix = covariate_matrix,
coefficients = beta,
family_object = family_object,
add_intercept = FALSE
)
# fit the reduced GLM
glm_fit_time <- system.time(
fit_reduced <- glm(
y ~ covariate_matrix_intercept_free_x_free,
family = family_object,
)
)[["elapsed"]]
# run residual precomputation and compute residual p-value
resid_time <- system.time({
precomputation_residual <- run_resid_precomputation(fit_reduced)
p_resid <- run_perm_test_resid_stat_binary_trt(permutations, precomputation_residual)$p
})[["elapsed"]]
# run score precomputation and comptue score p-value
score_time <- system.time({
precomputation_score <- run_score_stat_precomputation(fit_reduced)
p_score <- run_perm_test_score_stat_binary_trt(permutations, precomputation_score)$p
})[["elapsed"]]
# compute a standard GLM Wald p-value
fit_full <- glm(
y ~ covariate_matrix_intercept_free,
family = family_object,
)
lrt_test <- anova(fit_reduced, fit_full, test = "Chisq")
p_lrt <- lrt_test$`Pr(>Chi)`[2]
m[i,] <- c(p_resid = p_resid, p_score = p_score, p_lrt = p_lrt,
null_true = null_true, resid_time = glm_fit_time + resid_time,
score_time = glm_fit_time + score_time)
}
library(camp)
library(katlabutils)
conflicts_prefer(dplyr::filter)
library(tidyverse)
library(cowplot)
# define the parameters that control the simulation
gamma <- c(-0.6, 0.8, 0.9)
n_rep <- 500
n_cells <- 5000
mu_z <- c(0.0, 0.0)
rho <- 0.5
frac_null <- 0.9
# generate the covariate matrix
z <- cbind(1, MASS::mvrnorm(n = n_cells,
mu = c(0.0, 0.0),
Sigma = toeplitz(c(1, rho))))
mu_x <- as.numeric(binomial()$linkinv(z %*% gamma))
x <- rbinom(n = n_cells, size = 1, prob = mu_x)
covariate_matrix <- cbind(z, x)
colnames(covariate_matrix) <- c("intercept", "z1", "z2", "x")
covariate_matrix_intercept_free <- covariate_matrix[,-1]
covariate_matrix_intercept_free_x_free <- covariate_matrix[,c(-1, -4)]
# generate permutation idxs
permutations <- permute_bernoulli_treatment_vector(x)
# generate results matrix
m <- as.data.frame(matrix(nrow = n_rep, ncol = 6))
colnames(m) <- c("p_resid", "p_score", "p_lrt", "null_true", "resid_time", "score_time")
for (i in seq(1, n_rep)) {
if (i %% 5 == 0) print(i)
theta <- runif(1, 0.1, 5)
null_true <- as.logical(rbinom(1, 1, frac_null))
beta <- c(0.9, 0.1, 0.3, if (null_true) 0.0 else 0.1)
family_object <- MASS::negative.binomial(theta = theta)
y <- generate_glm_data(
design_matrix = covariate_matrix,
coefficients = beta,
family_object = family_object,
add_intercept = FALSE
)
# fit the reduced GLM
glm_fit_time <- system.time(
fit_reduced <- glm(
y ~ covariate_matrix_intercept_free_x_free,
family = family_object,
)
)[["elapsed"]]
# run residual precomputation and compute residual p-value
resid_time <- system.time({
precomputation_residual <- run_resid_precomputation(fit_reduced)
p_resid <- run_perm_test_resid_stat_binary_trt(permutations, precomputation_residual)$p
})[["elapsed"]]
# run score precomputation and comptue score p-value
score_time <- system.time({
precomputation_score <- run_score_stat_precomputation(fit_reduced)
p_score <- run_perm_test_score_stat_binary_trt(permutations, precomputation_score)$p
})[["elapsed"]]
# compute a standard GLM Wald p-value
fit_full <- glm(
y ~ covariate_matrix_intercept_free,
family = family_object,
)
lrt_test <- anova(fit_reduced, fit_full, test = "Chisq")
p_lrt <- lrt_test$`Pr(>Chi)`[2]
m[i,] <- c(p_resid = p_resid, p_score = p_score, p_lrt = p_lrt,
null_true = null_true, resid_time = glm_fit_time + resid_time,
score_time = glm_fit_time + score_time)
}
set.seed(4)
library(camp)
library(katlabutils)
conflicts_prefer(dplyr::filter)
library(tidyverse)
library(cowplot)
# define the parameters that control the simulation
gamma <- c(-0.6, 0.8, 0.9)
n_rep <- 500
n_cells <- 5000
mu_z <- c(0.0, 0.0)
rho <- 0.5
frac_null <- 0.9
# generate the covariate matrix
z <- cbind(1, MASS::mvrnorm(n = n_cells,
mu = c(0.0, 0.0),
Sigma = toeplitz(c(1, rho))))
mu_x <- as.numeric(binomial()$linkinv(z %*% gamma))
x <- rbinom(n = n_cells, size = 1, prob = mu_x)
covariate_matrix <- cbind(z, x)
colnames(covariate_matrix) <- c("intercept", "z1", "z2", "x")
covariate_matrix_intercept_free <- covariate_matrix[,-1]
covariate_matrix_intercept_free_x_free <- covariate_matrix[,c(-1, -4)]
# generate permutation idxs
permutations <- permute_bernoulli_treatment_vector(x)
# generate results matrix
m <- as.data.frame(matrix(nrow = n_rep, ncol = 6))
colnames(m) <- c("p_resid", "p_score", "p_lrt", "null_true", "resid_time", "score_time")
for (i in seq(1, n_rep)) {
if (i %% 5 == 0) print(i)
theta <- runif(1, 0.1, 5)
null_true <- as.logical(rbinom(1, 1, frac_null))
beta <- c(0.9, 0.1, 0.3, if (null_true) 0.0 else 0.1)
family_object <- MASS::negative.binomial(theta = theta)
y <- generate_glm_data(
design_matrix = covariate_matrix,
coefficients = beta,
family_object = family_object,
add_intercept = FALSE
)
# fit the reduced GLM
glm_fit_time <- system.time(
fit_reduced <- glm(
y ~ covariate_matrix_intercept_free_x_free,
family = family_object,
)
)[["elapsed"]]
# run residual precomputation and compute residual p-value
resid_time <- system.time({
precomputation_residual <- run_resid_precomputation(fit_reduced)
p_resid <- run_perm_test_resid_stat_binary_trt(permutations, precomputation_residual)$p
})[["elapsed"]]
# run score precomputation and comptue score p-value
score_time <- system.time({
precomputation_score <- run_score_stat_precomputation(fit_reduced)
p_score <- run_perm_test_score_stat_binary_trt(permutations, precomputation_score)$p
})[["elapsed"]]
# compute a standard GLM Wald p-value
fit_full <- glm(
y ~ covariate_matrix_intercept_free,
family = family_object,
)
lrt_test <- anova(fit_reduced, fit_full, test = "Chisq")
p_lrt <- lrt_test$`Pr(>Chi)`[2]
m[i,] <- c(p_resid = p_resid, p_score = p_score, p_lrt = p_lrt,
null_true = null_true, resid_time = glm_fit_time + resid_time,
score_time = glm_fit_time + score_time)
}
# process result data frame
m <- m |>
dplyr::mutate(p_resid_trans = -log(p_resid),
p_score_trans = -log(p_score),
p_lrt_trans = -log(p_lrt),
null_true = (null_true == 1))
# fit linear models
fit_score <- lm(formula = p_score_trans ~ p_lrt_trans + 0, data = m)
fit_resid <- lm(formula = p_resid_trans ~ p_lrt_trans + 0, data = m)
fit_score
fit_resid
# apply bh
fdr_level <- 0.1
n_nonnull <- sum(!m$null_true)
statistical_result_df <- m |> select(p_resid, p_score, p_lrt, null_true) |>
pivot_longer(cols = c("p_resid", "p_score", "p_lrt"),
names_to = "method", values_to = "p_val") |>
group_by(method) |>
mutate(p_adj = p.adjust(p_val, method = "BH"), signif = p_adj < fdr_level) |>
filter(signif) |>
summarize(n_total_discoveries = dplyr::n(),
n_false_discoveries = sum(null_true))
# assess mean running time
time_result_df <- m |> select(resid_time, score_time) |>
pivot_longer(cols = c("resid_time", "score_time"),
names_to = "method", values_to = "time") |>
group_by(method) |>
summarize(m_resid_time = mean(time),
m_score_time = mean(time),
upper_ci = m_resid_time + 1.96 * sd(time)/sqrt(n_rep),
lower_ci = m_resid_time - 1.96 * sd(time)/sqrt(n_rep))
# make plots
cols <- c("deepskyblue4", "firebrick2")
m <- m |> mutate(label = factor(x = null_true, levels = c(FALSE, TRUE),
labels = c("Alternative true", "Null true")))
p1 <- ggplot(m, aes(x = p_resid, y = p_lrt, col = label)) +
geom_point(size = 0.9) +
theme_bw() +
scale_x_continuous(trans = revlog_trans(base = 10)) +
scale_y_continuous(trans = revlog_trans(base = 10)) +
geom_abline(slope = 1, intercept = 0) +
xlab("p (perm. test w/ residual statistic)") +
ylab("p (GLM likelihood ratio test)") +
scale_color_manual(values = cols) +
theme(legend.position = "bottom", legend.title = element_blank())
legend <- get_legend(p1)
p1 <- p1 + theme(legend.position = "none")
p2 <- ggplot(m, aes(x = p_score, y = p_lrt, col = null_true)) +
geom_point(size = 0.9) +
theme_bw() +
scale_x_continuous(trans = revlog_trans(base = 10)) +
scale_y_continuous(trans = revlog_trans(base = 10)) +
geom_abline(slope = 1, intercept = 0) +
xlab("p (perm. test w/ score statistic)") +
ylab("p (GLM likelihood ratio test)") +
scale_color_manual(values = cols) + theme(legend.position = "none")
p1
p2
