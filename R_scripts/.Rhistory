.lec.SetPackageSeed(4) |> invisible()
snames <- as.character(seq(1, n_outer_rep))
.lec.CreateStream(snames) |> invisible()
.lec.CurrentStream(snames[proc_id]) |> invisible()
# define the parameters that control the simulation
gamma <- c(-0.6, 0.8, 0.9)
n_rep <- 500
n_cells <- 5000
mu_z <- c(0.0, 0.0)
rho <- 0.5
frac_null <- 0.9
# generate the covariate matrix
z <- cbind(1, MASS::mvrnorm(n = n_cells,
mu = c(0.0, 0.0),
Sigma = toeplitz(c(1, rho))))
mu_x <- as.numeric(binomial()$linkinv(z %*% gamma))
x <- rbinom(n = n_cells, size = 1, prob = mu_x)
covariate_matrix <- cbind(z, x)
colnames(covariate_matrix) <- c("intercept", "z1", "z2", "x")
covariate_matrix_intercept_free <- covariate_matrix[,-1]
covariate_matrix_intercept_free_x_free <- covariate_matrix[,c(-1, -4)]
# generate permutation idxs
permutations <- permute_bernoulli_treatment_vector(x)
# generate results matrix
colnames <- c("p_resid", "p_score", "p_lrt", "null_true", "resid_time", "score_time", "lrt_time")
m <- as.data.frame(matrix(nrow = n_rep, ncol = 7))
colnames(m) <- colnames
# sample the runs under the alternative hypothesis
null_idxs <- sample(seq(1, n_rep), size = frac_null * n_rep) |> sort()
for (i in seq(1, n_rep)) {
if (i %% 5 == 0) print(i)
theta <- runif(1, 0.1, 5)
null_true <- i %in% null_idxs
beta <- c(0.9, 0.1, 0.3, if (null_true) 0.0 else 0.1)
family_object <- MASS::negative.binomial(theta = theta)
y <- generate_glm_data(
design_matrix = covariate_matrix,
coefficients = beta,
family_object = family_object,
add_intercept = FALSE
)
# fit the reduced GLM
glm_fit_time <- system.time(
fit_reduced <- glm(
y ~ covariate_matrix_intercept_free_x_free,
family = family_object,
)
)[["elapsed"]]
# run residual precomputation and compute residual p-value
resid_time <- system.time({
precomputation_residual <- run_resid_precomputation(fit_reduced)
p_resid <- run_perm_test_resid_stat_binary_trt(permutations, precomputation_residual)$p
})[["elapsed"]]
# run score precomputation and comptue score p-value
score_time <- system.time({
precomputation_score <- run_score_stat_precomputation(fit_reduced)
p_score <- run_perm_test_score_stat_binary_trt(permutations, precomputation_score)$p
})[["elapsed"]]
# compute a standard GLM Wald p-value
lrt_time <- system.time({
fit_full <- glm(
y ~ covariate_matrix_intercept_free,
family = family_object,
)
lrt_test <- anova(fit_reduced, fit_full, test = "Chisq")
p_lrt <- lrt_test$`Pr(>Chi)`[2]
})[["elapsed"]]
m[i,] <- c(p_resid = p_resid,
p_score = p_score,
p_lrt = p_lrt,
null_true = null_true,
resid_time = glm_fit_time + resid_time,
score_time = glm_fit_time + score_time,
lrt_time = glm_fit_time + lrt_time)
}
library(statmod)
library(camp)
library(dplyr)
library(tidyr)
set.seed(4)
# define variables describing experiment
prob_perts <- c(0.001, 0.01, 0.05, 0.1, 0.5)
n_rep_per_setting <- 50
n_trt_vect <- 1000
n <- 100000
family_object <- MASS::negative.binomial(5)
# sapply over prob_perts
res <- sapply(prob_perts, function(prob_pert) {
# generate the treatment idxs
m <- matrix(data = rbinom(n_trt_vect * n, size = 1, prob_pert),
nrow = n, ncol = n_trt_vect)
trt_idxs <- apply(X = m, MARGIN = 2, FUN = function(col) which(col == 1) - 1L)
# iterate over reps per setting
out <- sapply(seq(1, n_rep_per_setting), FUN = function(rep_id) {
z <- MASS::mvrnorm(n = n, mu = c(-0.5, 0.5), Sigma = toeplitz(c(1, 0.5)))
y <- generate_glm_data(
design_matrix = z,
coefficients = c(0.6, 0.1, 0.3),
family_object = family_object,
add_intercept = TRUE
)
# fit the model
fit <- glm(
y ~ z, family = family_object
)
# compute the z-scores using eigen decomp
eigen_time <- system.time({
precomputation_score <- run_score_stat_precomputation(fit)
for (i in seq(1, n_trt_vect)) {
z_eigen <- camp:::compute_observed_full_statistic(a = precomputation_score$a,
w = precomputation_score$w,
D = precomputation_score$D,
s = length(trt_idxs[[i]]),
trt_idxs = trt_idxs[[i]])
}
})
# compute the z-scores using statmod
statmod_time <- system.time({
statmod_z <- statmod::glm.scoretest(fit = fit, x2 = m, dispersion = 1)
})
# output results
c(statmod_time = statmod_time[["elapsed"]],
eigen_time = eigen_time[["elapsed"]],
prob_pert = prob_pert,
rep_id = rep_id)
}) |> t() |> as.data.frame()
}, simplify = FALSE)
library(statmod)
library(camp)
library(dplyr)
library(tidyr)
set.seed(4)
# define variables describing experiment
prob_perts <- c(0.001, 0.01, 0.05, 0.1, 0.5)
n_rep_per_setting <- 50
n_trt_vect <- 1000
n <- 100000
family_object <- MASS::negative.binomial(5)
prob_pert <- prob_perts[1]
prob_pert
# generate the treatment idxs
m <- matrix(data = rbinom(n_trt_vect * n, size = 1, prob_pert),
nrow = n, ncol = n_trt_vect)
trt_idxs <- apply(X = m, MARGIN = 2, FUN = function(col) which(col == 1) - 1L)
rep_id <- 1
z <- MASS::mvrnorm(n = n, mu = c(-0.5, 0.5), Sigma = toeplitz(c(1, 0.5)))
y <- generate_glm_data(
design_matrix = z,
coefficients = c(0.6, 0.1, 0.3),
family_object = family_object,
add_intercept = TRUE
)
# fit the model
fit <- glm(
y ~ z, family = family_object
)
# fit the model
fit <- glm(y ~ z, family = family_object)
# compute the z-scores using eigen decomp
eigen_time <- system.time({
precomputation_score <- run_score_stat_precomputation(fit)
for (i in seq(1, n_trt_vect)) {
z_eigen <- camp:::compute_observed_full_statistic(a = precomputation_score$a,
w = precomputation_score$w,
D = precomputation_score$D,
s = length(trt_idxs[[i]]),
trt_idxs = trt_idxs[[i]])
}
})
# compute the z-scores using statmod
statmod_time <- system.time({
statmod_z <- statmod::glm.scoretest(fit = fit, x2 = m, dispersion = 1)
})
document()
github_packs <- c("katsevich-lab/lowmoi",
"timothy-barry/sceptre2",
"timothy-barry/ondisc@5adcc53", # install commit 5adcc53 (i.e, version 1.1.0)
"timothy-barry/camp@b1996c7",
"katsevich-lab/katlabutils",
"satijalab/seurat-data")
pack <- github_packs[4]
p_install_gh(pack)
# Github
github_packs <- c("katsevich-lab/lowmoi",
"timothy-barry/sceptre2",
"timothy-barry/ondisc@5adcc53", # install commit 5adcc53 (i.e, version 1.1.0)
"timothy-barry/camp@398dd2e",
"katsevich-lab/katlabutils",
"satijalab/seurat-data")
pack <- github_packs[4]
p_install_gh(pack)
camp:::compute_observed_full_statistic
dataset <- "papalexi"
analysis_type <- "calibration"
cat(dataset); cat("\n")
cat(analysis_type); cat("\n")
library(sceptre)
library(Matrix)
LOCAL_SCEPTRE2_DATA_DIR <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
LOCAL_SCEPTRE2_DATA_DIR
if (dataset == "papalexi") {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/papalexi/eccite_screen/r_objects.rds")
f_name <- paste0("papalexi_gene_", analysis_type, "_res.rds")
} else {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/frangieh/control/r_objects.rds")
f_name <- paste0("frangieh_control_", analysis_type, "_res.rds")
}
calibration_check <- analysis_type == "calibration"
l <- readRDS(objects_fp)
gc() |> invisible()
calibration_check
LOCAL_SCEPTRE2_DATA_DIR
res <- run_sceptre_lowmoi(response_matrix = l$response_matrix,
grna_matrix = l$grna_matrix,
covariate_data_frame = l$covariate_data_frame,
grna_group_data_frame = l$grna_group_data_frame,
formula_object = l$formula_object,
response_grna_group_pairs = l$response_grna_group_pairs,
calibration_check = calibration_check)
l$response_matrix
l$grna_matrix
l$covariate_data_frame
l$covariate_data_frame |> head()
l$grna_group_data_frame
head(l$grna_group_data_frame)
head(l$grna_group_data_frame)
l$grna_group_data_frame |> dplyr::rename(grna_group = grna_target)
l$grna_group_data_frame |> dplyr::rename(grna_group = grna_target) |> head()
res <- run_sceptre_lowmoi(response_matrix = l$response_matrix,
grna_matrix = l$grna_matrix,
covariate_data_frame = l$covariate_data_frame,
grna_group_data_frame = l$grna_group_data_frame |> dplyr::rename(grna_group = grna_target),
formula_object = l$formula_object,
response_grna_group_pairs = l$response_grna_group_pairs,
calibration_check = calibration_check)
res
l$response_matrix
l$grna_matrix
l$covariate_data_frame
l$response_grna_group_pairs,
l$response_grna_group_pairs
dataset <- "papalexi"
analysis_type <- "calibration"
cat(dataset); cat("\n")
cat(analysis_type); cat("\n")
library(sceptre)
library(Matrix)
LOCAL_SCEPTRE2_DATA_DIR <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
source("~/.Rprofile")
if (dataset == "papalexi") {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/papalexi/eccite_screen/r_objects.rds")
f_name <- paste0("papalexi_gene_", analysis_type, "_res.rds")
} else {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/frangieh/control/r_objects.rds")
f_name <- paste0("frangieh_control_", analysis_type, "_res.rds")
}
LOCAL_SCEPTRE2_DATA_DIR <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
if (dataset == "papalexi") {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/papalexi/eccite_screen/r_objects.rds")
f_name <- paste0("papalexi_gene_", analysis_type, "_res.rds")
} else {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/frangieh/control/r_objects.rds")
f_name <- paste0("frangieh_control_", analysis_type, "_res.rds")
}
calibration_check <- analysis_type == "calibration"
l <- readRDS(objects_fp)
gc() |> invisible()
l$response_grna_group_pairs
l$response_grna_group_pairs |> nrow()
l$response_matrix
l$grna_matrix
l$covariate_data_frame
l$grna_group_data_frame |> dplyr::rename(grna_group = grna_target)
l$grna_group_data_frame |> head()
l$grna_group_data_frame
l$formula_object
l$response_grna_group_pairs
calibration_check
calibration_check
l$response_grna_group_pairs
l$formula_object
l$grna_group_data_frame
l$covariate_data_frame
l$grna_matrix
l$response_matrix
res <- run_sceptre_lowmoi(response_matrix = l$response_matrix,
grna_matrix = l$grna_matrix,
covariate_data_frame = l$covariate_data_frame,
grna_group_data_frame = l$grna_group_data_frame,
formula_object = l$formula_object,
response_grna_group_pairs = l$response_grna_group_pairs,
calibration_check = calibration_check)
dataset <- "papalexi"
full_statistic <- TRUE
cat(paste0("dataset: ", dataset, "\n"))
cat(paste0("full statistic: ", full_statistic, "\n"))
library(sceptre)
library(Matrix)
LOCAL_SCEPTRE2_DATA_DIR <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
if (dataset == "papalexi") {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/papalexi/eccite_screen/r_objects.rds")
} else {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/frangieh/control/r_objects.rds")
}
l <- readRDS(objects_fp)
gc() |> invisible()
###################################################
# Prepare the analysis by creating a sceptre object
###################################################
# import data
response_matrix <- l$response_matrix
grna_matrix <- l$grna_matrix
grna_target_data_frame <- l$grna_group_data_frame
covariate_data_frame <- l$covariate_data_frame # |> dplyr::mutate(grna_n_umis = 1)
l$grna_group_data_frame |> head()
head( l$covariate_data_frame)
l$grna_group_data_frame |>
dplyr::rename(grna_target = grna_group)
l$grna_group_data_frame |>
dplyr::rename(grna_target = grna_group) |> head()
###################################################
# Prepare the analysis by creating a sceptre object
###################################################
# import data
response_matrix <- l$response_matrix
grna_matrix <- l$grna_matrix
grna_target_data_frame <- l$grna_group_data_frame
covariate_data_frame <- l$covariate_data_frame # |> dplyr::mutate(grna_n_umis = 1)
sceptre_object <- import_data(response_matrix = l$response_matrix,
grna_matrix = l$grna_matrix,
grna_target_data_frame = l$grna_group_data_frame |>
dplyr::rename(grna_target = grna_group),
moi = "low")
##################
# Run the analysis
##################
trans_pairs <- construct_trans_pairs(sceptre_object)
pc_pairs <- construct_positive_control_pairs(sceptre_object)
sceptre_object <- set_analysis_parameters(sceptre_object,
discovery_pairs = trans_pairs,
positive_control_pairs = pc_pairs,
full_test_stat = full_statistic)
# assign grnas
sceptre_object <- sceptre_object |> assign_grnas()
# run pairwise QC but not cellwise QC (as we have already run cellwise QC)
sceptre_object <- sceptre_object |> run_qc(p_mito_threshold = 0.1)
cat(paste0("dataset: ", dataset, "\n"))
cat(paste0("full statistic: ", full_statistic, "\n"))
library(sceptre)
library(Matrix)
LOCAL_SCEPTRE2_DATA_DIR <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
if (dataset == "papalexi") {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/papalexi/eccite_screen/r_objects.rds")
} else {
objects_fp <- paste0(LOCAL_SCEPTRE2_DATA_DIR, "data/frangieh/control/r_objects.rds")
}
l <- readRDS(objects_fp)
gc() |> invisible()
###################################################
# Prepare the analysis by creating a sceptre object
###################################################
# import data
response_matrix <- l$response_matrix
grna_matrix <- l$grna_matrix
grna_target_data_frame <- l$grna_group_data_frame
covariate_data_frame <- l$covariate_data_frame # |> dplyr::mutate(grna_n_umis = 1)
sceptre_object <- import_data(response_matrix = l$response_matrix,
grna_matrix = l$grna_matrix,
grna_target_data_frame = l$grna_group_data_frame |>
dplyr::rename(grna_target = grna_group),
moi = "low")
##################
# Run the analysis
##################
trans_pairs <- construct_trans_pairs(sceptre_object)
pc_pairs <- construct_positive_control_pairs(sceptre_object)
sceptre_object <- set_analysis_parameters(sceptre_object,
discovery_pairs = trans_pairs,
positive_control_pairs = pc_pairs,
full_test_stat = full_statistic)
# assign grnas
sceptre_object <- sceptre_object |> assign_grnas()
sceptre_object <- sceptre_object |> run_qc(p_mito_threshold = 0.1)
load_all()
###########################
# PLOT 2: REAL DATA RESULTS
###########################
library(tidyverse); conflicts_prefer(dplyr::filter)
library(katlabutils)
library(cowplot)
# set file paths, load results, source helpers
source(paste0(.get_config_path("LOCAL_CODE_DIR"),
"sceptre2-manuscript/R_scripts/figure_creation/shared_figure_script.R"))
sceptre2_dir <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
###########################
# PLOT 2: REAL DATA RESULTS
###########################
library(tidyverse); conflicts_prefer(dplyr::filter)
library(katlabutils)
library(cowplot)
# set file paths, load results, source helpers
source(paste0(.get_config_path("LOCAL_CODE_DIR"),
"sceptre2-manuscript/R_scripts/figure_creation/shared_figure_script.R"))
sceptre2_dir <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
# function for analyzing discovery results
analyze_discovery_results <- function(dataset) {
# set file paths
full_base_dir <- paste0(sceptre2_dir, "results/discovery_analyses/fig_s12/", dataset, "_full_stat")
resid_base_dir <- paste0(sceptre2_dir, "results/discovery_analyses/fig_s12/", dataset, "_resid_stat")
# define several functions
join_result_dfs <- function(full_stat_df, resid_stat_df) {
signif_present <- "significant" %in% colnames(full_stat_df)
left_join(full_stat_df[,c("response_id", "grna_target", "p_value", if (signif_present) "significant" else NULL)],
resid_stat_df[,c("response_id", "grna_target", "p_value", if (signif_present) "significant" else NULL)],
by = c("response_id", "grna_target"),
suffix = c("_full_stat", "_resid_stat"))
}
obtain_combined_df <- function(analysis_type, full_base_dir, resid_base_dir) {
full_stat_df <- readRDS(paste0(full_base_dir, "/results_", analysis_type, ".rds")) |> as.data.frame()
resid_stat_df <- readRDS(paste0(resid_base_dir, "/results_", analysis_type, ".rds")) |> as.data.frame()
join_result_dfs(full_stat_df, resid_stat_df)
}
clip_result_df <- function(combined_discovery_analysis_df) {
combined_discovery_analysis_df |>
na.omit() |>
mutate(p_value_full_stat = ifelse(p_value_full_stat < 1e-40, 1e-40, p_value_full_stat),
p_value_resid_stat = ifelse(p_value_resid_stat < 1e-40, 1e-40, p_value_resid_stat))
}
# load combined data frames
combined_calib_check_df <- obtain_combined_df("run_calibration_check", full_base_dir, resid_base_dir)
combined_power_check_df <- obtain_combined_df("run_power_check", full_base_dir, resid_base_dir)
combined_discovery_analysis_df <- obtain_combined_df("run_discovery_analysis", full_base_dir, resid_base_dir) |>
dplyr::filter(response_id != grna_target)
# create plot
my_breaks <- 10^(seq(from = 0, to = -6, by = -2))
p1 <- ggplot(clip_result_df(combined_calib_check_df),
aes(y = p_value_full_stat, x = p_value_resid_stat)) +
geom_point(size = 0.7, col = "indianred2", alpha = 0.7) +
theme_bw() +
scale_x_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
scale_y_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
geom_abline(slope = 1, intercept = 0) +
ylab("p (perm. score statistic)") +
xlab("p (perm. resid statistic)") +
my_theme +
ggtitle("Negative control pairs")
my_breaks <- 10^(seq(from = 0, to = -200, by = -20))
p2 <- ggplot(combined_power_check_df |> na.omit() |>
filter(p_value_full_stat > 1e-100, p_value_resid_stat > 1e-100),
aes(y = p_value_full_stat, x = p_value_resid_stat)) +
geom_point(size = 0.9, col = "mediumseagreen") +
theme_bw() +
scale_x_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
scale_y_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
geom_abline(slope = 1, intercept = 0) +
ylab("p (perm. score statistic)") +
xlab("p (perm. resid statistic)") +
my_theme +
ggtitle("Positive control pairs")
p3 <- ggplot(data = combined_discovery_analysis_df |>
na.omit() |> filter(p_value_full_stat > 1e-249, p_value_resid_stat > 1e-249),
aes(x = p_value_resid_stat, y = p_value_full_stat)) +
geom_point(size = 0.9, col = "dodgerblue3", alpha = 0.7) +
theme_bw() +
scale_x_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
scale_y_continuous(trans = revlog_trans(base = 10), breaks = my_breaks) +
geom_abline(slope = 1, intercept = 0) +
xlab("p (perm. resid statistic)") +
ylab("p (perm. score statistic)") +
my_theme +
ggtitle("Discovery pairs")
p4 <- ggplot() + theme_minimal()
p_final <- plot_grid(p1, p2, p3, p4, nrow = 2, labels = "auto")
# compute the number of discoveries (both discovery and calibration) as a function of FDR level
comute_n_rejections <- function(result_df) {
fdr_levels <- c(0.1, 0.05, 0.01, 0.005)
n_rejections_df <- result_df |>
na.omit() |>
select(p_value_full_stat, p_value_resid_stat) |>
pivot_longer(cols = c("p_value_full_stat", "p_value_resid_stat"),
names_to = "method", values_to = "p_value") |>
group_by(method) |>
mutate(q_value = p.adjust(p_value, method = "BH")) |>
reframe(n_reject = sapply(fdr_levels, function(fdr_level) sum(q_value < fdr_level)),
fdr_level = fdr_levels)
percent_change_df <- n_rejections_df |>
group_by(fdr_level) |>
reframe(percent_change = 100 * (n_reject[method == "p_value_full_stat"]/n_reject[method == "p_value_resid_stat"] - 1))
return(list(n_rejections_df = n_rejections_df, percent_change_df = percent_change_df))
}
# obtain the running times
resid_running_time <- readRDS(paste0(resid_base_dir, "/running_times.rds"))/(60^2)
full_running_time <- readRDS(paste0(full_base_dir, "/running_times.rds"))/(60^2)
running_time_matrix <- matrix(data = c(resid_running_time, full_running_time), nrow = 2)
rownames(running_time_matrix) <- c("calibration_check", "discovery_analysis")
colnames(running_time_matrix) <- c("resid", "full")
# determine proportion of pairs for which score yields smaller p-value than residuals
frac_score_more_signif <- combined_power_check_df |> na.omit() |>
mutate(p_value_full_stat < 0.05, p_value_resid_stat < 0.05) |>
mutate(score_more_signif = p_value_full_stat < p_value_resid_stat) |>
pull(score_more_signif) |> mean()
# return all
list(plot = p_final, running_time_matrix = running_time_matrix,
n_rejections_calib = comute_n_rejections(combined_calib_check_df),
n_rejections_discovery = comute_n_rejections(combined_discovery_analysis_df),
frac_score_more_signif = frac_score_more_signif)
}
papalexi_res <- analyze_discovery_results("papalexi")
frangieh_res <- analyze_discovery_results("frangieh")
frangieh_res$plot
to_save_fp <- paste0(.get_config_path("LOCAL_CODE_DIR"),
"sceptre2-manuscript/R_scripts/figure_creation/fig_s12/fig_s12.png")
