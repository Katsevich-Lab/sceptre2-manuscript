# STEP 2: RUN SIMULATION FUNCTION
#################################
run_simulation <- function(Y, idx_mat, Z, theta_hypothesized, n_sim = NULL, return_null_dist = FALSE) {
resamp_dist <- list()
if (is.null(n_sim)) n_sim <- ncol(Y)
out_m <- matrix(nrow = n_sim, ncol = 3)
for (i in seq(1, n_sim)) {
print(paste0("Running simulation ", i))
y <- Y[,i]
# regress the synthetic Y onto Z
fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta_hypothesized))
# extract z-scores
z_scores <- sceptre2:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
z_star
# compute theoretical and empirical p-values
p_theory <- 2 * pnorm(q = -abs(z_star), lower.tail = TRUE)
p_camp <- sceptre2:::compute_empirical_p_value(z_star = z_star, z_null = z_null, "both")
# finally, compute permutation
ts <- apply(X = idx_mat, MARGIN = 2, FUN = function(col) mean(y[col]))
t_star <- ts[1]
t_null <- ts[-1]
p_perm <- sceptre2:::compute_empirical_p_value(t_star, t_null, "both")
out_m[i,] <- c(p_theory = p_theory, p_camp = p_camp, p_perm = p_perm)
if (i == 1) {
resamp_dist[["camp_null"]] <- z_null
resamp_dist[["camp_star"]] <- z_star
resamp_dist[["perm_null"]] <- ts
resamp_dist[["perm_star"]] <- t_star
}
}
colnames(out_m) <- c("p_theory", "p_camp", "p_perm")
return(list(out_m = out_m, resamp_dist = resamp_dist))
}
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
# n_sim <- 2000
n_sim <- 10
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# run sim
sim_res_correlated <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = theta)
sim_res_correlated$out_m
sim_res_correlated$resamp_dist$camp_null |> head()
hist(sim_res_correlated$resamp_dist$camp_null)
abline(h = sim_res_correlated$resamp_dist$camp_star)
abline(v = sim_res_correlated$resamp_dist$camp_star)
sim_res_uncorrelated
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
# n_sim <- 2000
n_sim <- 10
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# generate x so that x is correlated with z
x <- sapply(X = mus_x, FUN = function(mu_x) rbinom(n = 1, size = 1, prob = mu_x))
x_idx <- which(x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x))) - 1L
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde)
# run sim
sim_res_correlated <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = theta)
sim_res_correlated$out_m
sim_res_correlated$out_m |> hist()
sim_res_correlated$resamp_dist$camp_null |> hist()
sim_res_correlated$resamp_dist$camp_star |> hist()
sim_res_correlated$resamp_dist$camp_star
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
# n_sim <- 2000
set.seed(1)
n_sim <- 10
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# generate x so that x is correlated with z
x <- sapply(X = mus_x, FUN = function(mu_x) rbinom(n = 1, size = 1, prob = mu_x))
x_idx <- which(x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x))) - 1L
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde)
# run sim
sim_res_correlated <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = theta)
# n_sim <- 2000
set.seed(1)
n_sim <- 10
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# generate x so that x is correlated with z
x <- sapply(X = mus_x, FUN = function(mu_x) rbinom(n = 1, size = 1, prob = mu_x))
x_idx <- which(x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x))) - 1L
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde)
# run sim
sim_res_correlated <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = theta, n_sim = 1)
sim_res_correlated$resamp_dist$camp_star |> hist()
sim_res_correlated$resamp_dist$camp_star
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
# n_sim <- 2000
set.seed(2)
n_sim <- 10
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# generate x so that x is correlated with z
x <- sapply(X = mus_x, FUN = function(mu_x) rbinom(n = 1, size = 1, prob = mu_x))
x_idx <- which(x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x))) - 1L
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde)
# run sim
sim_res_correlated <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = theta, n_sim = 1)
sim_res_correlated$resamp_dist$camp_star
set.seed(3)
n_sim <- 10
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
x <- sapply(X = mus_x, FUN = function(mu_x) rbinom(n = 1, size = 1, prob = mu_x))
x_idx <- which(x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x))) - 1L
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde)
# run sim
sim_res_correlated <- run_simulation(Y = Y, idx_mat = idx_mat, Z = Z,
theta_hypothesized = theta, n_sim = 1)
sim_res_correlated$resamp_dist$camp_star
saveRDS(object = sim_res_correlated,
file = paste0(result_dir, "correlated_sim_result.rds"))
library(ondisc)
library(sceptre2)
library(microbenchmark)
library(ggplot2)
library(katlabutils)
result_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/extra_analyses/")
# 1. load Papalexi data
response_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/gene")
grna_odm <- lowmoi::load_dataset_modality("papalexi/eccite_screen/grna_assignment")
grna_targets <- lowmoi::get_target_assignments_via_max_op(grna_odm)
# 2. get the gRNA group info
my_grna <- "CUL3"
grna_group_info <- sceptre2:::get_grna_group_info(grna_group_assignments = grna_targets,
input_grna_groups = my_grna)
idxs <- c(grna_group_info$grna_specific_idxs[[my_grna]],
grna_group_info$grna_specific_idxs[["non-targeting"]])
orig_x <- c(rep(1, grna_group_info$n_cells_per_grna[[my_grna]]),
rep(0, grna_group_info$n_cells_per_grna[["non-targeting"]]))
# 3. get covariate matrix
covariate_matrix_df <- response_odm |>
get_cell_covariates() |>
dplyr::slice(idxs) |>
dplyr::select(n_nonzero, n_umis, bio_rep, phase, p_mito)
row.names(covariate_matrix_df) <- NULL
Z <- model.matrix(object = formula(~ log(n_nonzero) + log(n_umis) + bio_rep + phase + p_mito),
data = covariate_matrix_df)
colnames(Z) <- c("intercept", "lg_n_nonzero", "lg_n_umis", "bio_rep_d1", "bio_rep_d2", "phase_d1", "phase_d2", "p_mito")
# 4. select gene
ex_gene <- "CXCL10"
orig_y <- as.numeric(response_odm[[ex_gene, idxs]])
# 5. get the model for y | Z
fit_y_orig <- MASS::glm.nb(formula = orig_y ~ . + 0, data = as.data.frame(Z))
y_coef <- coef(fit_y_orig)
theta <- fit_y_orig$theta
mus_y <- exp(as.numeric(Z %*% y_coef))
# 6. get the model for x | Z
b <- binomial()
fit_x <- glm(formula = orig_x ~ . + 0, family = binomial(), data = as.data.frame(Z))
x_coef <- coef(fit_x)
mus_x <- b$linkinv(as.numeric(Z %*% x_coef))
#################################
# STEP 2: RUN SIMULATION FUNCTION
#################################
run_simulation <- function(Y, idx_mat, Z, theta_hypothesized, n_sim = NULL, return_null_dist = FALSE, approx = TRUE) {
resamp_dist <- list()
if (is.null(n_sim)) n_sim <- ncol(Y)
out_m <- matrix(nrow = n_sim, ncol = 3)
for (i in seq(1, n_sim)) {
print(paste0("Running simulation ", i))
y <- Y[,i]
# regress the synthetic Y onto Z
fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta_hypothesized))
# extract z-scores
if (i == 1 || !approx) {
z_scores <- sceptre2:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat)
z_star <- z_scores[1]
z_null <- z_scores[-1]
} else {
z_star <- sceptre2:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat[,1,drop = FALSE])
}
# compute theoretical and empirical p-values
p_theory <- 2 * pnorm(q = -abs(z_star), lower.tail = TRUE)
p_camp <- sceptre2:::compute_empirical_p_value(z_star = z_star, z_null = z_null, "both")
# finally, compute permutation
ts <- sceptre2:::low_level_permutation_test(y = y, index_mat = idx_mat)
t_star <- ts[1]
t_null <- ts[-1]
p_perm <- sceptre2:::compute_empirical_p_value(t_star, t_null, "both")
out_m[i,] <- c(p_theory = p_theory, p_camp = p_camp, p_perm = p_perm)
if (i == 1) {
resamp_dist[["camp_null"]] <- z_null
resamp_dist[["camp_star"]] <- z_star
resamp_dist[["perm_null"]] <- ts
resamp_dist[["perm_star"]] <- t_star
}
}
colnames(out_m) <- c("p_theory", "p_camp", "p_perm")
return(list(out_m = out_m, resamp_dist = resamp_dist))
}
##############################################
# STEP 3: GENERATE CORRELATED DATA AND RUN SIM
##############################################
n_sim <- 2000
set.seed(3)
# y first
Y <- sapply(X = mus_y, FUN = function(mu_y) MASS::rnegbin(n = n_sim, mu = mu_y, theta = theta)) |> t()
# generate x so that x is correlated with z
x <- sapply(X = mus_x, FUN = function(mu_x) rbinom(n = 1, size = 1, prob = mu_x))
x_idx <- which(x == 1)
B <- 100000
x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
ps <- sapply(X = seq(1, n_sim), FUN = function(i) {
print(i)
y <- Y[,i]
ts <- sceptre2:::low_level_permutation_test(y = y, index_mat = idx_mat)
t_star <- ts[1]
t_null <- ts[-1]
sceptre2:::compute_empirical_p_value(z_star = t_star, z_null = t_null, "both")
})
########################################
# GENERATE UNCORRELATED DATA AND RUN SIM
########################################
# keep y from above
# generate x fresh
x <- rbinom(n = length(orig_x), size = 1, prob = mean(orig_x))
x_idx <- which(x == 1)
x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x)))
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
######################
# ASSESS RUNNING TIME
######################
y <- Y[,1]
# 1. regress y on Z
glm_time <- microbenchmark(fit <- glm(y ~ Z + 0,
family = MASS::negative.binomial(theta = theta)),
times = 30, unit = "s") |> summary()
# 2. permute x B times
x_idx <- which(x == 1)
B <- 100000
random_idx_time <- microbenchmark(x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x))),
times = 5, unit = "s") |> summary()
# 2. permute x B times
x_idx <- which(x == 1)
B <- 25000
random_idx_time <- microbenchmark(x_tilde <- replicate(n = B, expr = sample.int(n = length(x), size = sum(x))),
times = 5, unit = "s") |> summary()
idx_mat <- cbind(matrix(x_idx, ncol = 1), x_tilde) - 1L
# 3. get null z-scores
z_score_time <- microbenchmark(z_scores <- sceptre2:::run_glm_perm_score_test_with_ingredients(Z = Z,
working_resid = fit$residuals,
w = fit$weights,
index_mat = idx_mat), times = 30, unit = "s") |> summary()
z_score_time
2500000/25 000
2500000/25000
(2500000/25000) * 0.08
5000 * 50
(200000) * 0.08
(200000 * 0.08)/60
(200000 * 0.08)/(60^2)
(200000 * 0.08) + (0.01 * 200000 * 100 * 0.08)
(200000 * 0.08) + (0.01 * 200000 * 100 * 0.08) /(60^2)
((200000 * 0.08) + (0.01 * 200000 * 100 * 0.08)) /(60^2)
library(lowmoi)
library(tidyverse)
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
sample_size_df <- readRDS(paste0(sceptre2_results_dir, "dataset_sample_sizes/n_nonzero_cells_per_grna.rds"))
sceptre2_results_dir
head(sample_size_df)
# undercover res grp = 1
undercover_res <- readRDS(paste0(sceptre2_results_dir, "undercover_grna_analysis/undercover_result_grp_1.rds"))
undercover_res_extra <- readRDS(paste0(sceptre2_results_dir, "undercover_grna_analysis/undercover_result_grp_1_debug.rds")) |>
dplyr::mutate(method = forcats::fct_recode(method, "sceptre_no_covariates" = "sceptre"))
undercover_res_extra <- readRDS(paste0(sceptre2_results_dir, "undercover_grna_analysis/undercover_result_grp_1_our_methods.rds")) |>
dplyr::mutate(method = forcats::fct_recode(method, "sceptre_no_covariates" = "sceptre"))
undercover_res <- rbind(undercover_res, undercover_res_extra)
head(undercover_res)
undercover_res$method |> unique()
undercover_res_extra$method |> unique()
library(lowmoi)
library(tidyverse)
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
sample_size_df <- readRDS(paste0(sceptre2_results_dir, "dataset_sample_sizes/n_nonzero_cells_per_grna.rds"))
# undercover res grp = 1
undercover_res <- readRDS(paste0(sceptre2_results_dir, "undercover_grna_analysis/undercover_result_grp_1.rds"))
undercover_res_extra <- readRDS(paste0(sceptre2_results_dir, "undercover_grna_analysis/undercover_result_grp_1_our_methods.rds"))
head(undercover_res)
undercover_res$method |> unique()
undercover_res_extra$method |> unique()
undercover_res <- rbind(undercover_res, undercover_res_extra)
undercover_res_processed <- process_undercover_result(undercover_res, sample_size_df) |>
mutate(p_value = ifelse(p_value <= 0, 1e-8, p_value))
head(undercover_res_processed)
tail(undercover_res_processed)
nrow(undercover_res_processed)
saveRDS(undercover_res_processed, paste0(sceptre2_results_dir,
"undercover_grna_analysis/undercover_result_grp_1_processed.rds"))
rm(list = c("undercover_res", "undercover_res_extra", "undercover_res_processed"))
library(lowmoi)
library(tidyverse)
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
sample_size_df <- readRDS(paste0(sceptre2_results_dir, "dataset_sample_sizes/n_nonzero_cells_per_grna.rds"))
pc_res <- readRDS(paste0(sceptre2_results_dir, "positive_control_analysis/pc_results.rds"))
paste0(sceptre2_results_dir, "positive_control_analysis/pc_results.rds")
pc_ress_sceptre <- readRDS(paste0(sceptre2_results_dir, " pc_results_sceptre.rds"))
pc_res_sceptre <- readRDS(paste0(sceptre2_results_dir, "pc_results_sceptre.rds"))
sceptre2_results_dir
pc_res_sceptre <- readRDS(paste0(sceptre2_results_dir, "positive_control_analysis/pc_results_sceptre.rds"))
pc_res_sceptre
pc_res |> filter(method != "sceptre")
pc_res |> filter(method != "sceptre") |> group_by(dataset, method)
pc_res |> filter(method != "sceptre") |> group_by(dataset, method) |> summarize(count = n())
pc_res <- rbind(pc_res |> filter(method != "sceptre"), pc_res_sceptre)
pc_res
pc_res |> head()
pc_res |> group_by(dataset, method) |> summarize(count = n())
saveRDS(pc_res, paste0(sceptre2_results_dir, "positive_control_analysis/pc_results.rds"))
library(ondisc)
set.seed(4)
# Randomly generate data: First, randomly sample gene-specific mean and size parameters from gamma distribution.
# Then, for each gene, randomly sample from an NB distribution.
sceptre2_dir <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
# define hyperparameters
N_GENES <- 5000
N_GRNAS <- 30
N_NTC_GRNAS <- 25
N_CELLS <- 10000
library(ondisc)
set.seed(4)
# Randomly generate data: First, randomly sample gene-specific mean and size parameters from gamma distribution.
# Then, for each gene, randomly sample from an NB distribution.
sceptre2_dir <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
# define hyperparameters
N_GENES <- 5000
N_GRNAS <- 30
N_NTC_GRNAS <- 25
N_CELLS <- 10000
# generate cell names, gene names, and grna names
cell_barcodes <- paste0("cell-", seq(1, N_CELLS))
gene_ids <- paste0("gene-", seq(1, N_GENES))
grna_ids <- c(paste0("NTC-", seq(1, N_NTC_GRNAS)), paste0("GENE-TARGET-", seq(1, N_GRNAS -  N_NTC_GRNAS)))
# create gene expression matrix
mus <- rgamma(n = N_GENES, shape = 0.5, rate = 2)
thetas <- runif(n = N_GENES, min = 1, max = 25)
gene_expression_mat <- sapply(X = seq(1, N_GENES), FUN = function(i) {
MASS::rnegbin(N_CELLS, mus[i], thetas[i])
}) |> t()
rownames(gene_expression_mat) <- gene_ids
colnames(gene_expression_mat) <- cell_barcodes
# create grna expression matrix
grna_assignments <- sample(x = seq(1, N_GRNAS), size = N_CELLS, replace = TRUE)
head(grna_assignments)
10000/30
sceptre2_dir <- .get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
sceptre2_dir
sceptre2_dir
sceptre2_dir
sceptre2_results_dir
.get_config_path("LOCAL_SCEPTRE2_DATA_DIR")
sceptre2_results_dir <- paste0(.get_config_path("LOCAL_SCEPTRE2_DATA_DIR"), "results/")
sceptre2_results_dir
# load the sample size data frame
sample_size_df <- readRDS(paste0(sceptre2_results_dir, "dataset_sample_sizes/n_nonzero_cells_per_grna.rds"))
sample_size_df |> head()
sample_size_df$dataset_concat |> unique()
sample_size_df |>
dplyr::filter(dataset_concat %in% c("frangieh/ifn_gamma/gene",
"papalexi/eccite_screen/gene",
"schraivogel/enhancer_screen_chr11/gene"))
library(tidyverse)
x <- sample_size_df |>
dplyr::filter(dataset_concat %in% c("frangieh/ifn_gamma/gene",
"papalexi/eccite_screen/gene",
"schraivogel/enhancer_screen_chr11/gene")) |>
group_by(feature_id, dataset_concat, target)
head(x)
x <- sample_size_df |>
dplyr::filter(dataset_concat %in% c("frangieh/ifn_gamma/gene",
"papalexi/eccite_screen/gene",
"schraivogel/enhancer_screen_chr11/gene")) |>
group_by(feature_id, dataset_concat, target) |>
summarize(eff_ss = sum(n_nonzero_cells))
head(x)
tail(x)
tail(x, 100)
head(x)
eff_ss_df <- sample_size_df |>
dplyr::filter(dataset_concat %in% c("frangieh/ifn_gamma/gene",
"papalexi/eccite_screen/gene",
"schraivogel/enhancer_screen_chr11/gene")) |>
group_by(feature_id, dataset_concat, target) |>
summarize(eff_ss = sum(n_nonzero_cells))
head(eff_ss_df)
head(eff_ss_df, 50)
head(eff_ss_df, 50) |> print(n = 50)
x$dataset_concat |> unique()
x |> filter(dataset == "frangieh/ifn_gamma/gene") |> head()
x |> filter(dataset == "frangieh/ifn_gamma/gene")
head(X)
head(x)
x |> filter(dataset_concat == "frangieh/ifn_gamma/gene") |> head()
y <- x |> filter(dataset == "frangieh/ifn_gamma/gene") |> pull(eff_ss)
y <- x |> filter(dataset_concat == "frangieh/ifn_gamma/gene") |> pull(eff_ss)
head(y)
tail(y)
length(y)
mean(y >= 7)
# set different effective sample size levels; sample from each
eff_ss_levels <- c(7, 8, 9, 10, 12, 14, 16, 18, 20, 25, 30)
eff_ss_levels
length(eff_ss_levels)
head(eff_ss_df)
eff_ss_df |> filter(eff_ss %in% eff_ss_levels)
n_ex_per_eff_ss <- 5
n_ex_per_eff_ss
x <- eff_ss_df |> filter(eff_ss %in% eff_ss_levels)
head(x)
tail)x
tail(x)
head(x)
head(eff_ss_df)
eff_ss_df <- sample_size_df |>
dplyr::filter(dataset_concat %in% c("frangieh/ifn_gamma/gene",
"papalexi/eccite_screen/gene",
"schraivogel/enhancer_screen_chr11/gene")) |>
group_by(feature_id, dataset_concat, target) |>
summarize(eff_ss = sum(n_nonzero_cells)) |>
ungroup()
head(eff_ss_df)
head(eff_ss_df)
# set different effective sample size levels; sample from each
eff_ss_levels <- c(7, 8, 9, 10, 12, 14, 16, 18, 20, 25, 30)
eff_ss_df |>
group_by(dataset_concat, eff_ss)
eff_ss_df |>
group_by(dataset_concat, eff_ss) |>
sample_n(size = n_ex_per_eff_ss)
head(eff_ss_df)
eff_ss_df |>
filter(eff_ss %in% eff_ss_levels)
eff_ss_df |>
filter(eff_ss %in% eff_ss_levels) |>
group_by(dataset_concat, eff_ss)
x <- eff_ss_df |>
filter(eff_ss %in% eff_ss_levels) |>
group_by(dataset_concat, eff_ss) |>
sample_n(size = n_ex_per_eff_ss)
x
tail(x)
tail(x, 100)
tail(x, 250)
head(x)
set.seed(4)
x <- eff_ss_df |>
filter(eff_ss %in% eff_ss_levels) |>
group_by(dataset_concat, eff_ss) |>
sample_n(size = n_ex_per_eff_ss)
x
nrow(x)
nrow(x) * 250000
test <- numeric(length = 41250000)
length(test)
pryr::object_size(test)
head(x)
tail(x)
set.seed(4)
my_samp <- eff_ss_df |>
filter(eff_ss %in% eff_ss_levels) |>
group_by(dataset_concat, eff_ss) |>
sample_n(size = n_ex_per_eff_ss)
my_samp
nrow(my_samp)
n_ex_per_eff_ss <- 10
set.seed(4)
my_samp <- eff_ss_df |>
filter(eff_ss %in% eff_ss_levels) |>
group_by(dataset_concat, eff_ss) |>
sample_n(size = n_ex_per_eff_ss)
my_samp
nrow(my_samp)
nrow(my_samp)
my_samp
