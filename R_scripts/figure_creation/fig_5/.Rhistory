y_1 <- y[x_test == 1]
mu_hat_1 <- if (fitted_means) mu_hat[x_test == 1] else mus[x_test == 1]
s_y <- sum(y_1)
s_mu_hat <- sum(mu_hat_1)
# get the distilled z-score
z_score_distilled <- (s_y - s_mu_hat)/sqrt(s_mu_hat)
# get the normalized pearson residual sum
pearson_resid <- (y_1 - mu_hat_1)/sqrt(mu_hat_1)
sum_pearson <- sum(pearson_resid)
norm_sum_pearson <- (1/sqrt(length(pearson_resid))) * sum_pearson
# get the studentized residuals
#h <- VGAM::hatvalues(fit)[x_test == 1]
#boot_resid <- pearson_resid/sqrt(1 - h)
#norm_boot_resid <- (1/sqrt(length(boot_resid))) * sum(boot_resid)
# get the gcm
r <- y_1 - mu_hat_1
gcm <- 1/sqrt(length(r)) * sum(r)/sd(r)
c(z_score_distilled = z_score_distilled,
z_score_full = z_score_full,
norm_sum_pearson = norm_sum_pearson,
gcm = gcm)
# finally, get the empirically-normalized residual
# emp_norm_raw_resid <- (1/sqrt(n)) * sum(r_1)/sd(r_1)
# return
# c(z_score_distilled = z_score_distilled,
#  norm_sum_pearson = norm_sum_pearson,
#  emp_norm_raw_resid = emp_norm_raw_resid,
#  z_score_full = z_score_full)
}) |> t()
}
# true means
out_true_means <- run_experiment(fitted_means = FALSE, n_rep = 2000)
hist(out_true_means[,"z_score_full"], freq = FALSE, breaks = 20, main = "Full z-score")
lines(x = x_grid, y = y, col = "red")
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out_true_means[,"z_score_full"], freq = FALSE, breaks = 20, main = "Full z-score")
lines(x = x_grid, y = y, col = "red")
hist(out_true_means[,"z_score_distilled"], freq = FALSE, breaks = 20, main = "Distilled z-score")
lines(x = x_grid, y = y, col = "red")
hist(out_true_means[,"norm_sum_pearson"], freq = FALSE,
breaks = 20, main = "Normalized sum of Pearson residuals")
lines(x = x_grid, y = y, col = "red")
hist(out_true_means[,"gcm"], freq = FALSE,
breaks = 20, main = "GCM statistic")
lines(x = x_grid, y = y, col = "red")
####################
# Pt 2: fitted means
####################
out_fitted_means <- run_experiment(fitted_means = TRUE, n_rep = 2000, correlated = FALSE)
hist(out_fitted_means[,"z_score_full"], freq = FALSE,
breaks = 20, main = "Full z-score")
lines(x = x_grid, y = y, col = "red")
hist(out_fitted_means[,"z_score_distilled"], freq = FALSE,
breaks = 20, main = "Distilled z-score")
lines(x = x_grid, y = y, col = "red")
hist(out_fitted_means[,"norm_sum_pearson"], freq = FALSE,
breaks = 20, main = "Normalized sum of Pearson residuals")
lines(x = x_grid, y = y, col = "red")
plot(out_fitted_means[,"z_score_full"], out_fitted_means[,"z_score_distilled"])
abline(a = 0, b = 1, col = "red")
hist(out_fitted_means[,"gcm"], freq = FALSE,
breaks = 20, main = "gcm")
lines(x = x_grid, y = y, col = "red")
plot(out_fitted_means[,"z_score_full"], out_fitted_means[,"z_score_distilled"])
abline(a = 0, b = 1, col = "red")
####################################
# Pt 3 fitted means with correlation
####################################
out_fitted_means <- run_experiment(fitted_means = TRUE, n_rep = 2000, correlated = TRUE)
hist(out_fitted_means[,"z_score_full"], freq = FALSE,
breaks = 20, main = "Full z-score")
lines(x = x_grid, y = y, col = "red")
hist(out_fitted_means[,"z_score_distilled"], freq = FALSE,
breaks = 20, main = "Distilled z-score")
lines(x = x_grid, y = y, col = "red")
hist(out_fitted_means[,"norm_sum_pearson"], freq = FALSE,
breaks = 20, main = "Normalized sum of Pearson residuals")
lines(x = x_grid, y = y, col = "red")
hist(out_fitted_means[,"gcm"], freq = FALSE,
breaks = 20, main = "gcm")
lines(x = x_grid, y = y, col = "red")
###################
# Pt 3: comparisons
###################
plot(out_fitted_means[,"z_score_distilled"], out_fitted_means[,"z_score_full"])
abline(a = 0, b = 1, col = "red")
plot(out_fitted_means[,"z_score_distilled"], out_fitted_means[,"norm_sum_pearson"])
abline(a = 0, b = 1, col = "red")
###################
# Pt 3: comparisons
###################
plot(out_fitted_means[,"z_score_distilled"], out_fitted_means[,"z_score_full"])
abline(a = 0, b = 1, col = "red")
plot(out_fitted_means[,"z_score_distilled"], out_fitted_means[,"norm_sum_pearson"])
abline(a = 0, b = 1, col = "red")
out_true_means
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out_true_means[,"z_score_full"], freq = FALSE, breaks = 20, main = "Full z-score")
lines(x = x_grid, y = y, col = "red")
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out_true_means[,"z_score_full"], freq = FALSE, breaks = 20, main = "Full z-score")
lines(x = x_grid, y = y, col = "red")
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out_true_means[,"z_score_full"], freq = FALSE, breaks = 20, main = "Full z-score")
lines(x = x_grid, y = y, col = "red")
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out_true_means[,"z_score_full"], freq = FALSE, breaks = 20,
main = "Full z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
hist(out_true_means[,"z_score_distilled"], freq = FALSE, breaks = 20,
main = "Distilled z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
run_experiment <- function(fitted_means = FALSE, n_rep = 2000, correlated = FALSE) {
n <- 5000
beta_v <- c(1, 2, 1)
dat <- matrix(data = c(rep(1, n),
x1 = rbinom(n, 1, 0.4),
x2 = rnorm(n)),
ncol = 3)
lin_pred <- as.numeric(dat %*% beta_v)
mus <- exp(lin_pred)
if (correlated) {
x_test <- sapply(binomial()$linkinv(dat[,3] - 0.1), function(curr_mu) rbinom(n = 1, size = 1, prob = curr_mu))
} else {
x_test <- rbinom(n = n, size = 1, prob = 0.5)
}
out <- sapply(X = seq(1, n_rep), FUN = function(i) {
y <- sapply(mus, function(curr_mu) rpois(n = 1, lambda = curr_mu))
# we do a good job of estimating the parameters via glm
fit <- glm(y ~ dat[,-1], family = poisson)
mu_hat <- fit$fitted.values
z_score_full <- statmod::glm.scoretest(fit = fit, x_test)
# next, get the distilled z-score
y_1 <- y[x_test == 1]
mu_hat_1 <- if (fitted_means) mu_hat[x_test == 1] else mus[x_test == 1]
s_y <- sum(y_1)
s_mu_hat <- sum(mu_hat_1)
# get the distilled z-score
z_score_distilled <- (s_y - s_mu_hat)/sqrt(s_mu_hat)
# get the normalized pearson residual sum
pearson_resid <- (y_1 - mu_hat_1)/sqrt(mu_hat_1)
sum_pearson <- sum(pearson_resid)
norm_sum_pearson <- (1/sqrt(length(pearson_resid))) * sum_pearson
# get the gcm
r <- y_1 - mu_hat_1
gcm <- 1/sqrt(length(r)) * sum(r)/sd(r)
c(z_score_distilled = z_score_distilled,
z_score_full = z_score_full,
norm_sum_pearson = norm_sum_pearson,
gcm = gcm)
}) |> t()
}
out_true_means <- run_experiment(fitted_means = FALSE, n_rep = 2000)
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out_true_means[,"z_score_full"], freq = FALSE, breaks = 20,
main = "Full z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
hist(out_true_means[,"z_score_distilled"], freq = FALSE, breaks = 20,
main = "Distilled z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
out_true_means <- run_experiment(fitted_means = FALSE, n_rep = 2000)
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out_true_means[,"z_score_full"], freq = FALSE, breaks = 20,
main = "Full z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
hist(out_true_means[,"z_score_distilled"], freq = FALSE, breaks = 20,
main = "Distilled z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
mean(out_true_means[,"z_score_distilled"])
sd(out_true_means[,"z_score_distilled"])
out_true_means <- run_experiment(fitted_means = TRUE, n_rep = 2000, correlated = FALSE)
run_experiment <- function(fitted_means, n_rep, correlated) {
n <- 5000
beta_v <- c(1, 2, 1)
dat <- matrix(data = c(rep(1, n),
x1 = rbinom(n, 1, 0.4),
x2 = rnorm(n)),
ncol = 3)
lin_pred <- as.numeric(dat %*% beta_v)
mus <- exp(lin_pred)
if (correlated) {
x_test <- sapply(binomial()$linkinv(dat[,3] - 0.1), function(curr_mu) rbinom(n = 1, size = 1, prob = curr_mu))
} else {
x_test <- rbinom(n = n, size = 1, prob = 0.5)
}
out <- sapply(X = seq(1, n_rep), FUN = function(i) {
y <- sapply(mus, function(curr_mu) rpois(n = 1, lambda = curr_mu))
# we do a good job of estimating the parameters via glm
fit <- glm(y ~ dat[,-1], family = poisson)
mu_hat <- fit$fitted.values
z_score_full <- statmod::glm.scoretest(fit = fit, x_test)
# next, get the distilled z-score
y_1 <- y[x_test == 1]
mu_hat_1 <- if (fitted_means) mu_hat[x_test == 1] else mus[x_test == 1]
s_y <- sum(y_1)
s_mu_hat <- sum(mu_hat_1)
# get the distilled z-score
z_score_distilled <- (s_y - s_mu_hat)/sqrt(s_mu_hat)
# get the normalized pearson residual sum
pearson_resid <- (y_1 - mu_hat_1)/sqrt(mu_hat_1)
sum_pearson <- sum(pearson_resid)
norm_sum_pearson <- (1/sqrt(length(pearson_resid))) * sum_pearson
# get the gcm
r <- y_1 - mu_hat_1
gcm <- 1/sqrt(length(r)) * sum(r)/sd(r)
c(z_score_distilled = z_score_distilled,
z_score_full = z_score_full,
norm_sum_pearson = norm_sum_pearson,
gcm = gcm)
}) |> t()
}
out <- run_experiment(fitted_means = TRUE, n_rep = 2000, correlated = FALSE)
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out[,"z_score_full"], freq = FALSE, breaks = 20,
main = "Full z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
hist(out[,"z_score_distilled"], freq = FALSE, breaks = 20,
main = "Distilled z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
head(out)
hist(out[,"norm_sum_pearson"], freq = FALSE, breaks = 20,
main = "Distilled z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
plot(out[,"z_score_distilled"], out[,"z_score_full"])
abline(a = 0, b = 1, col = "red")
plot(out[,"z_score_distilled"], out[,"z_score_full"], ylab = "Z score", xlab = "Z dist")
abline(a = 0, b = 1, col = "red")
lm()
plot(out[,"z_score_distilled"], out[,"z_score_full"], ylab = "Z score", xlab = "Z dist")
abline(a = 0, b = 1, col = "red")
plot(out[,"z_score_distilled"], out[,"z_score_full"], ylab = "Z score", xlab = "Z dist")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(y = 0)
plot(out[,"z_score_distilled"], out[,"z_score_full"], ylab = "Z score", xlab = "Z dist")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(v = 0)
lm(out[,"z_score_full"] ~ out[,"z_score_distilled"])
plot(out[,"z_score_distilled"], out[,"z_score_full"], ylab = "Z distilled", xlab = "Z score")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(v = 0)
lm(out[,"z_score_full"] ~ out[,"z_score_distilled"])
plot(out[,"z_score_distilled"], out[,"z_score_full"], ylab = "Z score", xlab = "Z dist")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(v = 0)
lm(out[,"z_score_full"] ~ out[,"z_score_distilled"])
head(out)
plot(out[,"z_score_distilled"], out[,"norm_sum_pearson"], ylab = "Z score", xlab = "Z dist")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(v = 0)
plot(out[,"z_score_distilled"], out[,"norm_sum_pearson"], ylab = "Z score", xlab = "S Pearson")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(v = 0)
plot(out[,"z_score_distilled"], out[,"norm_sum_pearson"], ylab = "Z distilled", xlab = "S Pearson")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(v = 0)
out <- run_experiment(fitted_means = TRUE, n_rep = 2000, correlated = TRUE)
hist(out[,"z_score_full"], freq = FALSE, breaks = 20,
main = "Full z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
hist(out[,"z_score_distilled"], freq = FALSE, breaks = 20,
main = "Distilled z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
sd(out[,"z_score_distilled"])
head(out)
hist(out[,"norm_sum_pearson"], freq = FALSE, breaks = 20,
main = "Distilled z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
plot(out[,"z_score_distilled"], out[,"z_score_full"], ylab = "Z distilled", xlab = "Z score")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(v = 0)
lm(out[,"z_score_full"] ~ out[,"z_score_distilled"])
plot(out[,"z_score_distilled"], out[,"norm_sum_pearson"], ylab = "Z distilled", xlab = "S Pearson")
abline(a = 0, b = 1, col = "red")
abline(h = 0)
abline(v = 0)
out <- run_experiment(fitted_means = FALSE, n_rep = 2000, correlated = FALSE)
x_grid <- seq(from = -3.5, to = 3.5, by = 0.01)
y <- dnorm(x_grid)
hist(out[,"z_score_distilled"], freq = FALSE, breaks = 20,
main = "Theoretical distilled z-score", xlab = "")
lines(x = x_grid, y = y, col = "red")
n <- 5000
beta_v <- c(1, 2, 1)
dat <- matrix(data = c(rep(1, n),
x1 = rbinom(n, 1, 0.4),
x2 = rnorm(n)),
ncol = 3)
lin_pred <- as.numeric(dat %*% beta_v)
mus <- exp(lin_pred)
x_test <- rbinom(n = n, size = 1, prob = 0.5)
y <- sapply(mus, function(curr_mu) rpois(n = 1, lambda = curr_mu))
fit <- glm(y ~ dat[,-1], family = poisson)
fit
head(dat)
class(dat)
source("~/research_code/sceptre2-manuscript/writeups/score_test_exploration/exploration_1/score_explore.R", echo=TRUE)
n <- 5000
beta_v <- c(1, 2, 1)
Z <- matrix(data = c(rep(1, n),
x1 = rbinom(n, 1, 0.4),
x2 = rnorm(n)),
ncol = 3)
lin_pred <- as.numeric(Z %*% beta_v)
mus <- exp(lin_pred)
x_test <- rbinom(n = n, size = 1, prob = 0.5)
print(i)
y <- sapply(mus, function(curr_mu) rpois(n = 1, lambda = curr_mu))
fit <- glm(y ~ Z[,-1], family = poisson)
# first, get Z^T W Z
W <- fit$weights
head(W)
tail(W)
head(Z)
h <- diag(W) %*% Z
head(h)
W[i] * Z[i,]
i
WZ <- apply(seq(1, length(W)), function(i) {
W[i] * Z[i,]
})
WZ <- spply(X = seq(1, length(W)), FUN = function(i) {
W[i] * Z[i,]
})
WZ <- sapply(X = seq(1, length(W)), FUN = function(i) {
W[i] * Z[i,]
})
head(WZ)
class(WZ)
dim(WZ)
ZTW <- sapply(X = seq(1, length(W)), FUN = function(i) {
W[i] * Z[i,]
})
head(ZTW)
dim(ZTW)
ZTW[1:3,1:3]
P <- ZTW %*% Z
P
dim(P)
P <- t(Z) %*% diag(W) %*% Z
P
P <- ZTW %*% Z
P
# next, spectral decomposition of P
P_decomp <- eigen(P)
# next, spectral decomposition of P
P_decomp <- eigen(P)
P_decomp
u <- P_decomp$vectors
class(u)
Lambda <- diag(P_decomp$values)
Lambda
Lambda_minus_half <- 1/sqrt(Lambda)
t(u) %*% Lambda %*% u
P
P <- ZTW %*% Z
P
# next, spectral decomposition of P
P_decomp <- eigen(P)
u <- P_decomp$vectors
Lambda <- diag(P_decomp$values)
t(u) %*% Lambda %*% u
P
u %*% Lambda %*% t(u)
P
u %*% Lambda %*% t(u)
P
Lambda_minus_half <- 1/sqrt(Lambda)
u %*% Lambda %*% t(u)
Lambda_minus_half
sqrt(Lambda)
Lambda_minus_half <- diag(1/sqrt(P_decomp$values))
Lambda_minus_half
head(Z)
head(ZTW)
dim(ZTW)
# u %*% Lambda %*% t(u) -> check that this equals P
B <- Lambda_minus_half %*% t(u) %*% ZTW
dim(B)
class(B)
B[1:3, 1:3]
x
X
x_test <- rbinom(n = n, size = 1, prob = 0.5)
head(x_test)
# check that B %*% X
L <- B %*% X
X <- rbinom(n = n, size = 1, prob = 0.5)
# check that B %*% X
L <- B %*% X
head(L)
class(L)
# check that B %*% X
L <- as.numeric(B %*% X)
head(L)
tail(L)
L[1:10]
head(X)
B[1:3,1:10]
is.na(B) |> any()
dim(X)
X <- as.matrix(rbinom(n = n, size = 1, prob = 0.5), ncol = 1)
head(X)
head(X)
dim(B)
# check that B %*% X
L <- as.numeric(B %*% X)
L |> head()
class(L)
L[1:10-]
L[1:10]
dim(B)
dim(X)
B %*% X
B %*% X |> dim()
# check that B %*% X
L <- as.numeric(B %*% X)
L
class(L)
L
sum(L^2)
product <- sum(L^2)
product
head(X)
# get product
product <- sum(L^2)
head(product)
?residulas
?residuals.glm
M_y_muhat <- fit$residuals
head(M_y_muhat)
tail(M_y_muhat)
length(M_y_muhat)
numerator <- sum(X * W * M_y_muhat)
numerator
head(Z)
head(X)
head(W)
head(M_y_muhat)
head(S)
head(W)
# finally, get the first part of the denominator
sum(x * W * x)
# finally, get the first part of the denominator
sum(X * W * X)
# get product
denom_2 <- sum(L^2)
denom_2
# finally, get the first part of the denominator
demon_1 <- sum(X * W * X)
# finally, get the first part of the denominator
denom_1 <- sum(X * W * X)
# combine all
numerator/(sqrt(denom_1 + denom_2))
# compare to original score test
statmod::glm.scoretest(fit, X)
head(X)
fit <- glm(y ~ Z[,-1], family = poisson)
# first, get P = Z^T W Z
W <- fit$weights
ZTW <- sapply(X = seq(1, length(W)), FUN = function(i) {
W[i] * Z[i,]
})
P <- ZTW %*% Z
# next, spectral decomposition of P
P_decomp <- eigen(P)
u <- P_decomp$vectors
Lambda <- diag(P_decomp$values)
Lambda_minus_half <- diag(1/sqrt(P_decomp$values))
# u %*% Lambda %*% t(u) -> check that this equals P
# compute B
B <- Lambda_minus_half %*% t(u) %*% ZTW
# compute L
L <- as.numeric(B %*% X)
# get product
denom_2 <- sum(L^2)
# next, focus on the numerator
M_y_muhat <- fit$residuals
numerator <- sum(X * W * M_y_muhat)
# finally, get the first part of the denominator
denom_1 <- sum(X * W * X)
# combine all
numerator/(sqrt(denom_1 + denom_2))
# compare to original score test
statmod::glm.scoretest(fit, X)
# combine all
numerator/(sqrt(denom_1 - denom_2))
# combine all
numerator/(sqrt(denom_1 - denom_2))
# compare to original score test
statmod::glm.scoretest(fit, X)
